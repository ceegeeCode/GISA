{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10540\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Outline of rawRarity1 in SAonGISA_v10_unix.c:\
\
1. Set file names of files to be outputted.\
\
2. Get content of desired directory (of the query pdb\'92s). 
\f1 \expnd0\expndtw0\kerning0
ListDirectoryContents/ListDirectoryContents2\

\f0 \kerning1\expnd0\expndtw0 \
3. Bulk memory allocation  to chain-info keeping pointer, 
\f1 \expnd0\expndtw0\kerning0
chainInStr
\f0 \kerning1\expnd0\expndtw0 .\
\
4.If CATH data, read in the \'93positive list\'94, 
\f1 \expnd0\expndtw0\kerning0
cathListPath.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 5. Fetch chain info of the query structures. Here, if CATH data, take intersection with CATH positive list. Also get the max chain length and the number of sub-structures.\
\
6. Allocate memory to pointer holding the Gauss invariants\'92 values, 
\f1 I_measures. \
\

\f0 7. Allocate memory to pointer holding the 3d-coord\'92s of each chain (ptr_chain).\
\
8. Allocate memory to some pointers for query: to hold I-values on window pairs, the binned version and for the scores (
\f1 alloc_init_I_windowPairs_ptr, alloc_init_queryRawScore, alloc_init_ptr_binned_I_windowPairs, alloc_init_ptr_Irarity_windowPairs).\
\

\f0 9. Define/allocate to a convenience pointer holding mutual I-values for query. 
\f1 \
\

\f0 10. Load data base (DB): read in the DB of I-values for pairs  
\f1 (readDBresultsWindowPairsToPtr)\
\
11. 
\f0 Define/allocate to a convenience pointer holding mutual I-values for DB.\
\
12. Bin DB and sort it all lexicographically. First generate the set of bins (
\f1 generateBinsPairs)
\f0 , then bin the whole DB (
\f1 binDBresultsWindowPairs
\f0 ) and finally sort it (
\f1 heapSortBinnedDBPairs
\f0 ).\
  
\f1 \

\f0 13. Create an array holding the number of occurences of/size of match set for each word in the data base.\
\
14. Read in rarityScore-data and generate the distribution of these (
\f1 readSortRarityScoreData\
).\
\

\f0 15. Allocate and initialize ptr,  
\f1 ptr_matchIndicator,
\f0  to hold a match indicator for the matching obtained in each "word search\'94. this consists in a 0/1-array (1 indicating match).\
\
16. Define/allocate pointer to hold match ranges for the nrOfEntries I-values to match on ( 
\f1 ptr_newRange).
\f0 \
\
17. A couple of allocation for read-out names.\
\
18. Main loop starts here. Consists in outer loop over the query files (structures) and an inner loop over the chains in each query structure.\
\
18.1. We skip the chain if it is too long (if it length is above the pre-defined 
\f1 maxChainLength\

\f0 ). If CATH data, check if query is in positive list of CATH domains (else continue to next structure).\
\
18.2. Reinitialize the chain-info pointer (
\f1 reinit_chainInStr\

\f0 ) and fetch the chain info (
\f1 readPDBChainStructureSCOP\

\f0 , 
\f1 readPDBDomainStructureCATH\
, readPDBChainStructure2)\
\

\f0 19. Inner loop over the sub-structures of the query file starts here.\
\
19.1. If CATH data, the domain is a subset of a single chain, so if the current chain is \'93the wrong one\'94 we skip it.\
\
19.2. Set som structure/chain characteristics in the the pointer holding the I-values. And set a chain-length.\
\
19.3. If SCOP data, we skip the chain if it is class h, i, j or k.\
\
19.4. Read in the 3d-coord chain (
\f1 main_readPDB2
\f0 ) and populate the pointer holding the 3d-coord array (
\f1 ptr_segment
\f0 ).\
19.4.1. Skip chain if it contains a too long segment.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 19.5. Initialize the I-values in the pointer holding the I-values 
\f1 (I_measures).\

\f0 \
19.6. Compute the I-values for the query (populate the 
\f1 I_measures
\f0  pointer with the Gauss integral values). (
\f1 aggrAndW, aggrAndW_ExAbs
\f0  or 
\f1 wVal+aggr
\f0 ).\
\
20. The actual scoring/matching starts here.\
\
20.1. Derive the values of the invariants on the window pairs (
\f1 getInvariantsOnWindowPairs\

\f0 ) for the query. This populates the 
\f1 I_windowPairs
\f0  pointer.\
\
20.2. Normalize the query\'92s window pairs values if desired (
\f1 normalizeQueryWindowPairsPtr\

\f0 ).\
\
20.3. Load the query\'92s window values into the convenience pointer (
\f1 ptr_query_pairs\

\f0 ). This distinguishes between the (desired) number of invariants used for the matching (
\f1 nrOfEntriesForPairs
\f0 ). If that parameter is 1 only the mutual writhe will be used; if 2 also the mutual writhe of the abs-value writhe will be used; if above 2 the mutual values of all the order 2 invariants will be used too (incl the ab-value ones, if these are desired \'97 takes setting incl_abs_b = 1). \
\
20.4. Bin the pairs-results (for query).\
\
20.5. Loop over the query\'92s window pairs in a double loop over the windows. Only consider the \'93upper triangular plus the diagonal\'94. Within this loop the core of the matching/scoring takes place.\
\
20.5.1. Find the max-mutual abs I-value (for the invariants that are considered). Actual \'93single window pairs\'94, ie pairs of the same window (k=l), are disregarded.\
 \
20.5.2. Skip the pair: if the two segments (windows) are not disjoint (ie they overlap); if their max-mutual abs I-value is below the set threshold.\
\
20.5.3. Look up the word of this window pair (query) in the data base; this amounts to looking up the word 
\f1 ptr_binned_I_windowPairs_query[cntPairs]
\f0  in the array of word counts 
\f1 (ptr_binned_I_counts). \

\f0 If we do not allow mismatches, this is a direct look-up in the pre-populated 
\f1 ptr_binned_I_counts
\f0  pointer.\
If we do allow mismatches, that pointer is not pre-populated, so we make the search and record the results as the outer loop over windows and queries progress: first we try looking up in 
\f1 ptr_binned_I_counts
\f0 ; if there is no hit we search the data base for hits, allowing the desired number of mismatches; the hits we find we then record in the 
\f1 ptr_binned_I_counts
\f0  pointer so that any upcoming search for the same word will be caught by a simple look-up in that very pointer.
\f1 \

\f0 The data base search part is done as follows: after an initial potential memory reallocation, first the match-indicator pointer is reset to 0 every where. Then a search for the desired word (\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 ptr_binned_I_windowPairs_query[cntPairs])
\f0  is made 
\f1 (bisectionalSearchSingle_Pairs
\f0 ). All hits are recorded in the match-indicator and their number is counted (
\f1 cntMatch
\f0 ). \
Finally the convenience pointer 
\f1 ptr_binned_I_counts
\f0  is updated with the new matches and the order of that array is re-done (
\f1 bubbleSort_binned_I_counts
\f0 ).\

\f1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 20.5.4. The rarity factor for the pair (probability of finding the pair\'92s word in the data base) can now be computed (the ratio of cntMatch and the number of pairs in the data base plus a small \'93pseudo ratio\'94 to avoid log-of-zero when computing the score, which is just -log(probability)).\
\
20.5.5. Record the rarity factor (
\f1 collect_Irarity_windowPairs\

\f0 ).\
\
20.5.6. Loop over pairs ends here.\
\
20.6. Sum up the scores obtained (for each window pair) and build a string to be written to file, containing all the window pair info of the scoring.\
\
20.7. Compute the score as the average score across all pairs. \
\
20.8. If a p-value of the query\'92s score is desired make a look-up i(
\f1 bisectionalSearchValueL) i
\f0 n the supplied data base of scores (held in pointer 
\f1 ptr_rarityScorePairsDistr)
\f0 .  
\f1 \
\

\f0 20.9. Collect all the results to be written out in the pointer 
\f1 ptr_queryRawScore
\f0  (
\f1 collect_queryRawScore
\f0 ). \
\
20.10. End of inner-loop (loop-over-chains) ends here.\
\
19.7. End of outer loop over files ends here.\
\
21. Sort the obtained score results (
\f1 heapSortRawScores
\f0 ) and write to file if desired. Close the output file.\
\
22. Free some memory (
\f1 ptr_segment, ptr_chain, I_measures
\f0  and 
\f1 dirContent.ptr_dirList).\

\f0 \
23. Report some run-times plus how many files and chins were processed and how many query window pairs that had a mutual I-value above the set threshold.\
\
  
\f1 \

\f0 \
     \
 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \
}