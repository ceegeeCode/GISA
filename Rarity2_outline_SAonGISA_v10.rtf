{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww37900\viewh20960\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Outline of rawRarity2 in SAonGISA_v10_unix.c:\
\
\
1. Set file names of files to be outputted.\
\
2. Get content of desired directory (of the query pdb\'92s). 
\f1 \expnd0\expndtw0\kerning0
ListDirectoryContents/ListDirectoryContents2\

\f0 \kerning1\expnd0\expndtw0 \
3. Bulk memory allocation  to chain-info keeping pointer, 
\f1 \expnd0\expndtw0\kerning0
chainInStr
\f0 \kerning1\expnd0\expndtw0 .\
\
4.If CATH data, read in the \'93positive list\'94, 
\f1 \expnd0\expndtw0\kerning0
cathListPath.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 5. Fetch chain info of the query structures. Here, if CATH data, take intersection with CATH positive list. Also get the max chain length and the number of sub-structures.\
\
6. Allocate memory to pointer holding the Gauss invariants\'92 values, 
\f1 I_measures. \
\

\f0 7. Allocate memory to pointer holding the 3d-coord\'92s of each chain (ptr_chain).\
\
8. Allocate memory to some pointers for query, for matching used on single windows or, possibly, pairs: to hold I-values on, the binned version and for the scores \
(for single windows: \
\pard\pardeftab720\sl360\partightenfactor0

\f1 \cf0 alloc_init_I_windows_ptr, alloc_init_queryRawScore, \
alloc_init_ptr_binned_I_windows\
alloc_init_ptr_Irarity_windows;\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 for pairs: \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 alloc_init_I_windowPairs_ptr, alloc_init_queryRawScore, alloc_init_ptr_binned_I_windowPairs, alloc_init_ptr_Irarity_windowPairs).\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 9. Define/allocate to a convenience pointer holding mutual I-values for query, single windows, and, if pairs-based matching is desired, for the pairs case too. 
\f1 \
\

\f0 10. Load data base (DB): This goes in one of two ways depending on whether the pairs-matching is included or not.\
a. If pairs matching is desired (): read in the DB of I-values for pairs 
\f1 (readDBresultsWindowPairsToPtr
\f0 ). Define/allocate to two conveniences pointers for the DB side: one for  holding the \'93word pairs\'94 \'97 binned I-vectors \'97 for the pairs\'92 match (
\f1 binnedIvector_matchPair)
\f0  and one for holding the mutual I-values of the pairs (
\f1 ptr_match_pairs
\f0 ). \
\
Next, to fetch the single window I-values, these are loaded from the pairs results/values (
\f1 loadDBWindowsFromDBPairs
\f0 ).\
\
b. In case the pairs matching is not desired, only the single window I-values are needed; they are loaded directly from file (
\f1 readDBresultsWindowsToPtr
\f0 ).\
\
In both cases we also define/allocate to a convenience pointer, 
\f1 ptr_match,
\f0  similar to  
\f1 ptr_match_pairs
\f0  for the holding the single window I-values for matching (still DB side, that is).\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 \
11. Normalize the DB results if desired. This includes both single window I\'92s and pairs I-values (the latter must be normalized after the load of the single values results, as these are fetched from the pairs results).\
\
12. Bin single windows DB (
\f1 ptr_dbResultWindows
\f0 ) and sort it all lexicographically. First generate the set of bins (
\f1 generateBins)
\f0 , then bin the whole DB (
\f1 binDBresultsWindows
\f0 ) and finally sort it (
\f1 heapSortBinnedDB
\f0 ).\
  \
13. Read in rarityScore-data and generate the distribution of these (
\f1 readSortRarityScoreData\
).\
\

\f0 14. Allocate and initialize ptr,  
\f1 ptr_matchIndicator,
\f0  to hold a match indicator for the matching obtained in each "word search\'94. this consists in a 0/1-array (1 indicating match).\
\
15. Allocate and initialize a ptr, 
\f1 ptr_ptr_binned_I_windows_matchSet,
\f0  to hold the match set of words from all matches found in the single  windows matching for a given query  (
\f1 alloc_init_ptr_ptr_binned_I_windows
\f0 ).\
\
16. Define/allocate pointer to hold match ranges for the nrOfEntries I-values to match on ( 
\f1 ptr_newRange).
\f0  \
\
17. A couple of allocation for read-out names.\
\
18. Main loop starts here. Consists in outer loop over the query files (structures) and an inner loop over the chains in each query structure.\
\
18.1. We skip the chain if it is too long (if it length is above the pre-defined 
\f1 maxChainLength\

\f0 ). If CATH data, check if query is in positive list of CATH domains (else continue to next structure).\
\
18.2. Reinitialize the chain-info pointer (
\f1 reinit_chainInStr\

\f0 ) and fetch the chain info (
\f1 readPDBChainStructureSCOP\

\f0 , 
\f1 readPDBDomainStructureCATH\
, readPDBChainStructure2)\
\

\f0 19. Inner loop over the sub-structures of the query file starts here.\
\
19.1. If CATH data, the domain is a subset of a single chain, so if the current chain is \'93the wrong one\'94 we skip it.\
\
19.2. Set som structure/chain characteristics in the the pointer holding the I-values. And set a chain-length.\
\
19.3. If SCOP data, we skip the chain if it is class h, i, j or k.\
\
19.4. Read in the 3d-coord chain (
\f1 main_readPDB2
\f0 ) and populate the pointer holding the 3d-coord array (
\f1 ptr_segment
\f0 ).\
19.4.1. Skip chain if it contains a too long segment.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 19.5. Initialize the I-values in the pointer holding the I-values 
\f1 (I_measures).\

\f0 \
19.6. Compute the I-values for the query (populate the 
\f1 I_measures
\f0  pointer with the Gauss integral values). (
\f1 aggrAndW, aggrAndW_ExAbs
\f0  or 
\f1 wVal+aggr
\f0 ).\
\
20. The actual scoring/matching starts here. First a single window based matching is done; then, if desired, a window pair based version is added.\
\
20.1. Derive the values of the invariants on the single windows (
\f1 getInvariantsOnWindows\

\f0 ) for the query. This populates the 
\f1 I_windows
\f0  pointer.\
\
20.2. Normalize the query\'92s window pairs values if desired (
\f1 normalizeQueryWindowsPtr\

\f0 ).\
\
20.3. Load the query\'92s window values into the convenience pointer (
\f1 ptr_query
\f0 ). This distinguishes between the (desired) number of invariants used for the matching (
\f1 nrOfEntries
\f0 ). If that parameter is 1 only the mutual writhe will be used; if 2 also the mutual writhe of the abs-value writhe will be used; if above 2 the mutual values of all the order 2 invariants will be used too (incl the ab-value ones, if these are desired \'97 takes setting incl_abs_b = 1). \
\
20.4. Bin the query results (
\f1 binQueryResultsWindows
\f0 ).\
\
20.5. If pairs-matching is desired, reset the match-indicator.\
\
20.6. Loop over the query\'92s windows. Within this loop the core of the matching/scoring for the query\'92s windows takes place.\
\
20.6.1. Look up the word of this window (of query) in the data base; this amounts to looking up the word 
\f1 ptr_binned_I_windows_query[window-index]
\f0  in the binned back ground data base 
\f1 (ptr_binned_I_windows_DB). T
\f0 his may allow a pre-set number of mismatches. \
\
20.6.2. Keep track of the match count. Also, if pairs-based matching is to be done, save the matches (in the ptr dedicated to the purpose).\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 20.6.3. The rarity factor for each window (probability of finding the word in the data base) can now be computed (the ratio of cntMatch and the number of windows in the data base plus a small \'93pseudo ratio\'94 to avoid log-of-zero when computing the score, which is just -log(probability)).\
\
20.6.4. Record the rarity factor (
\f1 collect_Irarity_windows
\f0 ).\
\
20.6.5. Loop over windows ends here.\
\
20.7. Sum up the scores obtained (for each window) and build a string to be written to file, containing all the windows info of the scoring.\
\
20.8. Compute the windows\'92 score as the average score across all windows (of the query). \
\
20.7. If a p-value of the query\'92s score is desired make a look-up i(
\f1 bisectionalSearchValueL) i
\f0 n the supplied data base of scores (held in pointer 
\f1 ptr_rarityScorePairsDistr)
\f0 .  
\f1 \
\

\f0 20.8. Collect all the results to be written out in the pointer 
\f1 ptr_queryRawScore
\f0  (
\f1 collect_queryRawScore
\f0 ). \
\
\
21. The (possible) pairs-matching start here. \
\
21.1. Derive the values of the invariants on the window pairs (
\f1 getInvariantsOnWindowPairs\

\f0 ) for the query. This populates the 
\f1 I_windowPairs
\f0  pointer.\
\
21.2. Normalize the query\'92s window pairs values if desired (
\f1 normalizeQueryWindowPairsPtr\

\f0 ).\
\
21.3. Load the query\'92s window values into the convenience pointer (
\f1 ptr_query_pairs\

\f0 ). This distinguishes between the (desired) number of invariants used for the matching (
\f1 nrOfEntriesForPairs
\f0 ). If that parameter is 1 only the mutual writhe will be used; if 2 also the mutual writhe of the abs-value writhe will be used; if above 2 the mutual values of all the order 2 invariants will be used too (incl the ab-value ones, if these are desired \'97 takes setting incl_abs_b = 1). \
\
21.4. Bin the pairs-results (for query).\
\
21.5. Loop over the query\'92s window pairs in a double loop over the windows. Only consider the \'93upper triangular plus the diagonal\'94. Within this loop the core of the matching/scoring for the pairs-case takes place.\
\
20.4.1. Find the max-mutual abs I-value (for the invariants that are considered). Actual \'93single window pairs\'94, ie pairs of the same window (k=l), are disregarded.\
 \
20.4.2. Skip the pair: if the two segments (windows) are not disjoint (ie they overlap); if their max-mutual abs I-value is below the set threshold.\
\
20.4.3. Look up the word of this window pair (query) in the match set found in the single window case.\
To achieve this we loop twice over the window-match set, while skipping the match-pairs that do not belong to the same data base entry (the same structure).\
\
20.4.4. For a given match-pair read in its I-values for the relevant (found) windows into the convenience pointer, 
\f1 ptr_match_pairs
\f0 . \
\
20.4.5. Bin the match-pair window results (to obtain a \'93pairs word\'94); then compute the difference of the two words, the query\'92s and the match pairs. We here allow a mismatching of at most one for each letter, ie invariant, considered (nrOfEntriesforPairs in total). So if one of the letters is 2 or more off, the match pair is \'93disqualified\'94.\
\
20.4.6. If the total difference his below the accepted number of mismatches, we increment the match-count by 1.\
\
20.4.7. Double loop over match set ends here.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0 \cf0 20.4.8. The rarity factor for the pair (probability of finding the pair\'92s word in the data base) can now be computed (the ratio of cntMatch_12 and the number of pairs in the data base plus a small \'93pseudo ratio\'94 to avoid log-of-zero when computing the score, which is just -log(probability)).\
\
20.4.9. Record the rarity factor (
\f1 collect_Irarity_windowPairs
\f0 ).\
\
20.4.10. Loop over pairs ends here.\
\
20.5. Sum up the scores obtained (for each window pair) and build a string to be written to file, containing all the window pair info of the scoring.\
\
20.6. Compute the score as the average score across all pairs. \
\
20.7. If a p-value of the query\'92s pairs-score is desired make a look-up i(
\f1 bisectionalSearchValueL) i
\f0 n the supplied data base of pairs-scores (held in pointer 
\f1 ptr_rarityScorePairsDistr)
\f0 .  
\f1 \
\

\f0 20.8. Collect all the results to be written out in the pointer 
\f1 ptr_queryRawScore
\f0  (
\f1 collect_queryRawScore
\f0 ). \
\
20.9. End of inner-loop (loop-over-chains) ends here.\
\
19.7. End of outer loop over files ends here.\
\
21. Sort the obtained score results for single windows and pairs (
\f1 heapSortRawScores
\f0 ) and write to files if desired. Close the output files.\
\
22. Free some memory (
\f1 ptr_segment, ptr_chain, I_measures
\f0  and 
\f1 dirContent.ptr_dirList).\

\f0 \
23. Report some run-times plus how many files and chins were processed and how many query window pairs that had a mutual I-value above the set threshold.\
\
  
\f1 \

\f0 \
     \
 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\fs28 \cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs24 \cf0 \
}