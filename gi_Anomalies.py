# -*- coding: utf-8 -*-
"""
Created on Wed Mar 08 09:26:10 2017

@author: Christian Grønbæk

This version: id to the file of the same name in forFirstVersion except for changes of paths to files, name of code-files, removal of some parts
that were not used (plots not used) and a few cosmetic things.
"""

'''
Usage:

The code in this module allows to generate the plots in the Paper and the Supplementary Data. To run it on your
own machine
1) run the GISA_main_v* with appropriate settings (v    alues of parameters and paths to folders)
2) run the code below on the output generated in 1. (For this you must of course change the path names, e.g. the 
   "root" below, and possbly file names if you have made some changes in the C-code to how they are generated)
3) Pymol versions of plots (examples of links/pokes) can be made by running the accompanying pymol scripts, 
   gi_Anomalies_restrictedSearch.txt and gi_Anomalies_unrestrictedSearch.txt (see inside these files for their usage)   

Obs!: if not using the pymol option, but using the plots of examples (link/pokes) generated by the python code
below, the indices on the segments appearing as annotation in the plots refer to the numbers of the residues simply
obtained by counting them from the start of the chain (the first C-alpha getting the index 0). These indices may
therefore deviate from the residue numbers in the PDB-files. 
If instead you use the pymol scripts the indices are the residue numbers in the PDB-file.

#############################################################################
# Generating plots for main GISA paper
#############################################################################


import gi_Anomalies as git

root = r'C:\Users\Christian\Sync\Bioinformatics\papers\structural_alignment_by_GIs\results\v10\top100'


#top100 set:

set = 'top100'

#restricted search (here 1bpi is found):
pokeLength = 10
loopLength = 30
#Ex file name : ClosedLoopChars_minmax_computeGI_top100_closedLoopLength_30_closedLoopDist_7.0_pokeLength10
fileName = root + r'\ClosedLoopChars_minmax_computeGI_'+ set + '_closedLoopLength_' +str(loopLength) + '_closedLoopDist_7.0' + '_pokeLength' + str(pokeLength) +'.txt'

#in case your pymol runs on your own machine while the results were generated on a server: replace the server's path, and have the pdb-files on your own machine: 
fileNameNew = root + r'\ClosedLoopChars_minmax_computeGI_'+ set + '_closedLoopLength_' +str(loopLength) + '_closedLoopDist_7.0' + '_pokeLength' + str(pokeLength) +'_pathReplaced.txt'
serverDataRoot =  '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/'
thisPCdataRoot = r'C:\\Users\\Christian\\Sync\\Bioinformatics\\data\\structural\\Kinemage\\top100H\\'
git.replacePath(fileName, fileNameNew, serverDataRoot, thisPCdataRoot)
fileName = fileNameNew

dict_top100_cl, links_top100_cl, pokesAll_top100_cl, pokesMin_top100_cl, pokesMax_top100_cl = git.readResultsCcode_closedLoops(inputFileName = fileName, normalize_b = 1, minMaxOut_b =1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)

chainsFile = root + r'\chains_closed_loops_' + set +'.txt'
#again replace paths if pymol is on your own machine:
chainsFileNew = root + r'\chains_closed_loops_' + set +'_pathReplaced.txt'
git.replacePath(chainsFile, chainsFileNew, serverDataRoot, thisPCdataRoot, replaceEntryAt = 3)
chainsFile = chainsFileNew

titlePokesI = 'Distribution of writhe values for potential pokes of length ' + str(pokeLength) 
titlePokesII = ' writhe values for potential pokes of length ' + str(pokeLength) 
pokes_top100_cl = pokesAll_top100_cl, pokesMin_top100_cl, pokesMax_top100_cl
fig = git.histoClosedLoops_minMax(links_top100_cl, pokes_top100_cl, pokesMinMax_b =1, color = 'lightgrey', binsLinks=100, binsPokes =100, linksDistrPlotsInSubPlots_b =2, pokesDistrPlotsInSubPlots_b =1, linksShowTopNr = 100, pokesShowTopNr = 100, cutOffLinks = 0.85, cutOffPokes = 0.8, plotPokeExs_b = 0, plotLinkExs_b = 0, plotLinksTop10_b = 1, plotPokesTop10_b = 0, chainsFile = chainsFile,  intervalLinks = [-0.3,-.15], intervalPokes = [-0.35, -0.34], plotExsInInt_b =0, titleLinks = 'Distribution of writhe values', titlePokesI = titlePokesI, titlePokesII = titlePokesII, stringPattern = '([\S]+)([^\w]+)([\w]+)', lowerPercentile = 0.5, upperPercentile = 0.5, use_pymol_b = 0)

#Results
Top 5 link values:
[[0.9684176420910524, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1difH', 'A', (15, 36), (72, 87)], [0.40186392356036094, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1hfcH', '>', (111, 127), (129, 144)], [0.39811908732688017, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1hfcH', '>', (121, 128), (129, 144)], [0.3655521662516442, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1hfcH', '>', (111, 127), (128, 140)], [0.31662371913920356, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1kapH', 'P', (259, 268), (269, 279)]]
Top 5 lowest link values:
[[-0.8962163655376418, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1bpiH', '>', (8, 20), (29, 46)], [-0.2572173063483081, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1xicH', '>', (219, 245), (247, 259)], [-0.22132356949762222, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/2cbaH', '>', (94, 101), (103, 113)], [-0.16777923114815896, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1bpiH', '>', (21, 28), (29, 46)], [-0.15990321005684188, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/3lzmH', '>', (16, 23), (24, 31)]]
Top 5 poke values:
[[0.9612072865492172, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1difH', 'A', (15, 36), (76, 86)], [0.8656395974482983, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1difH', 'A', (72, 87), (25, 35)], [0.8645293325652893, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1difH', 'B', (72, 87), (25, 35)], [0.7949963682102857, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1cusH', '>', (1, 27), (47, 57)], [0.7763121349335981, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1cusH', '>', (2, 28), (47, 57)]]
Top 5 lowest poke values:
[[-0.9477144487837725, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1bpiH', '>', (29, 46), (11, 21)], [-0.846322962005235, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1phbH', '>', (49, 77), (281, 291)], [-0.8404879439041284, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1phbH', '>', (50, 78), (281, 291)], [-0.8186280124704567, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/2cplH', '>', (83, 102), (119, 129)], [-0.7883265824326622, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1ammH', '>', (110, 135), (159, 169)]]

#unrestricted search, lgth 30 (here 2cpl is found):
subChainLength = 30
#Ex file name: SubChainPairChars_minmax_computeGI_top100_subChainLength_30
fileName= root + r'\SubChainPairChars_minmax_computeGI_' + set + '_subChainLength_' + str(subChainLength) + '.txt'
dict_top100, extremeWrithes_top100_All, extremeWrithes_top100_Min, extremeWrithes_top100_Max = git.readResultsCcode_closedLoops(inputFileName = fileName, linksAndPokes_b = 0, minMaxOut_b = 1, normalize_b = 1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_subchain_pairs_' + set + '.txt'
#convert structure and then plot
extremeWrithes_top100 = extremeWrithes_top100_All, extremeWrithes_top100_Min, extremeWrithes_top100_Max
git.histoSubChainPairs_minMax(extremeWrithes_top100, bins=100, color = 'lightgrey', addSubplotToFirstPlot_b = 1, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 1, plotExs_b = 0, chainsFile = chainsFile, interval = [-4,-3], plotExsInInt_b =0, stringPattern = '([\S]+)([^\w]+)([\w]+)', subChainLgth =  30, lowerPercentile = 0.05, upperPercentile = 0.95)

#Results:
Top 10 values:
[[1.266735916718127, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1difH', 'B', (14, 44), (65, 95)], [1.2635756565906229, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1difH', 'A', (14, 44), (65, 95)], [1.0723550509167594, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1kapH', 'P', (50, 80), (102, 132)], [1.0025344935795888, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/2trxAH', 'A', (9, 39), (39, 69)], [0.999561160932746, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/2olbH', 'A', (351, 381), (381, 411)], [0.9586230081607626, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/2ctcH', '>', (51, 81), (81, 111)], [0.874076878446429, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1tcaH', '>', (22, 52), (52, 82)], [0.8727675903070835, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/5p21H', '>', (0, 30), (47, 77)], [0.8523458625166616, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1phbH', '>', (49, 79), (299, 329)], [0.8384108127418362, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1mrjH', '>', (107, 137), (137, 167)]]
Top 10 lowest values:
[[-1.7490388971088637, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/2cplH', '>', (70, 100), (102, 132)], [-1.1760382097208772, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1nifH', '>', (230, 260), (260, 290)], [-1.0769812872250832, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1phpH', '>', (239, 269), (269, 299)], [-1.0658060637409426, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/2olbH', 'A', (245, 275), (464, 494)], [-1.0116587668895756, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1mlaH', '>', (126, 156), (162, 192)], [-0.9719486536584893, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1rcfH', '>', (103, 133), (134, 164)], [-0.9387814001379106, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1ttaAH', 'A', (4, 34), (51, 81)], [-0.9351303857433825, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1ammH', '>', (106, 136), (138, 168)], [-0.9127839972261504, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/2ayhH', '>', (66, 96), (161, 191)], [-0.8797910979457289, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1litH', '>', (8, 38), (99, 129)]]

Subchain lgth 15:
Top 5 values:
[[1.022083017774737, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1difH', 'A', (23, 38), (71, 86)], [1.0171835920065961, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1difH', 'B', (23, 38), (71, 86)], [0.929285022570975, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1kapH', 'P', (51, 66), (108, 123)], [0.7557653909353775, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/8abpH', '>', (222, 237), (237, 252)], [0.7496091981591114, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1lamH', '>', (370, 385), (385, 400)]]
Top 5 lowest valu es:
[[-1.0224318854099945, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1arbH', '>', (152, 167), (168, 183)], [-1.020343056359385, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1bpiH', '>', (9, 24), (29, 44)], [-0.9399777678451323, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/7rsaH', '>', (71, 86), (94, 109)], [-0.8602420962857514, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1ptxH', '>', (0, 15), (41, 56)], [-0.8470707515053524, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top100H/1litH', '>', (92, 107), (109, 124)]]



#To generate distr plot (in main Paper):

#top8000 set:

root = r'C:\Users\Christian\Sync\Bioinformatics\papers\structural_alignment_by_GIs\results\v10\top8000'

set = 'top8000'

#restricted search:
pokeLength = 10
loopLength = 30
fileName = root + r'\ClosedLoopChars_minmax_computeGI_'+ set + '_closedLoopLength_' +str(loopLength) + '_closedLoopDist_7.0' + '_pokeLength' + str(pokeLength) +'.txt'
dict_top8000_cl, links_top8000_cl, pokesAll_top8000_cl,  pokesMin_top8000_cl, pokesMax_top8000_cl = git.readResultsCcode_closedLoops(inputFileName = fileName, normalize_b = 1, minMaxOut_b = 1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_closed_loops_' + set + '.txt'
titlePokesI = 'Distribution of writhe values for potential pokes of length ' + str(pokeLength) 
titlePokesII = ' writhe values for potential pokes of length ' + str(pokeLength) 
pokes_top8000_cl = pokesAll_top8000_cl, pokesMin_top8000_cl, pokesMax_top8000_cl
plotLinksTop10_b = 1
plotPokesTop10_b = 0
fig = git.histoClosedLoops_minMax(links_top8000_cl, pokes_top8000_cl, pokesMinMax_b =1, color = 'grey', supTitle_b = 0, binsLinks=100, binsPokes =100, linksDistrPlotsInSubPlots_b =2, pokesDistrPlotsInSubPlots_b =0, linksShowTopNr = 100, pokesShowTopNr = 100, cutOffLinks = 0.9, cutOffPokes = 0.9, plotPokeExs_b = 0, plotLinkExs_b = 0, plotLinksTop10_b = plotLinksTop10_b , plotPokesTop10_b = plotPokesTop10_b , chainsFile = chainsFile, intervalLinks = [-1.1,-.95], intervalPokes = [-0.75,-.74], plotExsInInt_b =0, titlePokesI = titlePokesI, titlePokesII = titlePokesII, lowerPercentile = 0.1, upperPercentile = 0.9)


Top 10 link values:
[[1.0008429152669367, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1pqhFH_B.pdb', 'B', (9, 34), (52, 76)], [0.9902522678887727, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2qd6FH_A.pdb', 'A', (15, 36), (72, 86)], [0.9849510554667963, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ualFH_A.pdb', 'A', (84, 107), (115, 139)], [0.9644000938625837, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2egvFH_A.pdb', 'A', (157, 178), (186, 212)], [0.9611558795025985, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3o7bFH_A.pdb', 'A', (142, 161), (169, 197)], [0.9580304743076314, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2egvFH_A.pdb', 'A', (156, 172), (186, 212)], [0.9531285020604011, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3aiaFH_A.pdb', 'A', (131, 147), (156, 184)], [0.9524877442595131, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3m3gFH_A.pdb', 'A', (26, 54), (72, 93)], [0.9508817117287728, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2ha8FH_B.pdb', 'B', (76, 94), (105, 133)], [0.9493038496229598, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ualFH_A.pdb', 'A', (85, 108), (115, 139)]]
Top 10 lowest link values:
[[-1.0138851853884883, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3hmsFH_A.pdb', 'A', (3, 31), (56, 78)], [-0.9979071431866635, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (188, 210)], [-0.9940547182116527, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (182, 203)], [-0.988471562807989, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (59, 82)], [-0.9867504612533933, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (188, 210)], [-0.9809087586446767, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (182, 203)], [-0.9808674579369444, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (60, 83)], [-0.9758115032822726, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (61, 84)], [-0.9742362672330206, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (179, 202)], [-0.969170285816934, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (179, 202)]]

Top 10 poke values:
[[0.9632946036278675, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2i6dFH_A.pdb', 'A', (174, 196), (216, 226)], [0.9534636027930811, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2qd6FH_A.pdb', 'A', (15, 36), (76, 86)], [0.9521641822602074, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3m3gFH_A.pdb', 'A', (26, 54), (72, 82)], [0.9485570946299725, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1j71FH_A.pdb', 'A', (210, 228), (290, 300)], [0.9389867895919708, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ualFH_A.pdb', 'A', (84, 107), (126, 136)], [0.9368159957456689, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3aiaFH_A.pdb', 'A', (156, 184), (131, 141)], [0.9357220442443267, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ualFH_A.pdb', 'A', (115, 139), (84, 94)], [0.9344863652661612, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3o7bFH_A.pdb', 'A', (142, 161), (182, 192)], [0.9324744876305365, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3mk1FH_A.pdb', 'A', (386, 406), (417, 427)], [0.9306564607155978, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3mk1FH_A.pdb', 'A', (387, 407), (417, 427)]]
Top 10 lowest poke values:
[[-1.049274003182215, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (192, 202)], [-1.0392454910630518, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2jh1FH_A.pdb', 'A', (169, 199), (156, 166)], [-1.0283491866166796, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (192, 202)], [-1.0034116760484397, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1kntFH_A.pdb', 'A', (28, 45), (10, 20)], [-0.9980790305252027, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (153, 169), (192, 202)], [-0.9778549731741011, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1zr0FH_D.pdb', 'D', (29, 46), (11, 21)], [-0.9755629032611631, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1tawFH_B.pdb', 'B', (27, 44), (9, 19)], [-0.9712864099402839, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (151, 168), (192, 202)], [-0.9707826845453981, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3bybFH_B.pdb', 'B', (30, 47), (12, 22)], [-0.9677781575297093, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3m7qFH_B.pdb', 'B', (27, 44), (9, 19)]]

There were 12 links having a writhe value below the cutoff: -0.950000
[[-0.9629107219051298, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (153, 169), (182, 203)], [-0.969073201301648, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (153, 169), (188, 210)], [-0.969170285816934, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (179, 202)], [-0.9742362672330206, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (179, 202)], [-0.9758115032822726, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (61, 84)], [-0.9808674579369444, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (60, 83)], [-0.9809087586446767, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (182, 203)], [-0.9867504612533933, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (188, 210)], [-0.988471562807989, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (59, 82)], [-0.9940547182116527, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (182, 203)], [-0.9979071431866635, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (188, 210)], [-1.0138851853884883, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3hmsFH_A.pdb', 'A', (3, 31), (56, 78)]]
There were 9 links having a writhe value above the cutoff: 0.950000
[[1.0008429152669367, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1pqhFH_B.pdb', 'B', (9, 34), (52, 76)], [0.9902522678887727, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2qd6FH_A.pdb', 'A', (15, 36), (72, 86)], [0.9849510554667963, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ualFH_A.pdb', 'A', (84, 107), (115, 139)], [0.9644000938625837, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2egvFH_A.pdb', 'A', (157, 178), (186, 212)], [0.9611558795025985, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3o7bFH_A.pdb', 'A', (142, 161), (169, 197)], [0.9580304743076314, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2egvFH_A.pdb', 'A', (156, 172), (186, 212)], [0.9531285020604011, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3aiaFH_A.pdb', 'A', (131, 147), (156, 184)], [0.9524877442595131, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3m3gFH_A.pdb', 'A', (26, 54), (72, 93)], [0.9508817117287728, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2ha8FH_B.pdb', 'B', (76, 94), (105, 133)]]

There were 31 links having a writhe value below the cutoff: -0.900000
[[-0.9034318140376559, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (150, 167), (179, 202)], [-0.9036897246229363, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1tawFH_B.pdb', 'B', (6, 18), (27, 44)], [-0.9078546503287082, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2hq6FH_A.pdb', 'A', (82, 102), (114, 138)], [-0.9108986477702837, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2x7kFH_A.pdb', 'A', (67, 87), (99, 122)], [-0.9110122048221798, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2bt6FH_A.pdb', 'A', (48, 71), (78, 102)], [-0.9110305076406354, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1xlqFH_C.pdb', 'C', (45, 68), (75, 100)], [-0.916395302462377, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (151, 168), (179, 202)], [-0.9169932475835733, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2fu0FH_A.pdb', 'A', (73, 93), (105, 128)], [-0.9237708608351416, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1i7hFH_A.pdb', 'A', (44, 66), (75, 100)], [-0.9252288792688064, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (150, 167), (182, 203)], [-0.9253289081505397, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2a2nFH_C.pdb', 'C', (82, 103), (114, 137)], [-0.929382823283505, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2bt6FH_A.pdb', 'A', (45, 68), (78, 102)], [-0.9346033441493337, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2vveFH_A.pdb', 'A', (11, 39), (44, 71)], [-0.935713051990042, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (150, 167), (188, 210)], [-0.9358567689036539, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1xlqFH_C.pdb', 'C', (42, 64), (75, 100)], [-0.9373057155055625, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3hmsFH_A.pdb', 'A', (3, 31), (66, 83)], [-0.9373619767779455, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (151, 168), (182, 203)], [-0.943701436471182, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (153, 169), (179, 202)], [-0.9447793929007433, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (151, 168), (188, 210)], [-0.9629107219051298, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (153, 169), (182, 203)], [-0.969073201301648, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (153, 169), (188, 210)], [-0.969170285816934, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (179, 202)], [-0.9742362672330206, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (179, 202)], [-0.9758115032822726, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (61, 84)], [-0.9808674579369444, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (60, 83)], [-0.9809087586446767, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (182, 203)], [-0.9867504612533933, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (157, 171), (188, 210)], [-0.988471562807989, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3fdrFH_A.pdb', 'A', (10, 37), (59, 82)], [-0.9940547182116527, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (182, 203)], [-0.9979071431866635, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3dqpFH_A.pdb', 'A', (159, 174), (188, 210)], [-1.0138851853884883, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3hmsFH_A.pdb', 'A', (3, 31), (56, 78)]]
There were 21 links having a writhe value above the cutoff: 0.900000
[[1.0008429152669367, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1pqhFH_B.pdb', 'B', (9, 34), (52, 76)], [0.9902522678887727, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2qd6FH_A.pdb', 'A', (15, 36), (72, 86)], [0.9849510554667963, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ualFH_A.pdb', 'A', (84, 107), (115, 139)], [0.9644000938625837, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2egvFH_A.pdb', 'A', (157, 178), (186, 212)], [0.9611558795025985, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3o7bFH_A.pdb', 'A', (142, 161), (169, 197)], [0.9580304743076314, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2egvFH_A.pdb', 'A', (156, 172), (186, 212)], [0.9531285020604011, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3aiaFH_A.pdb', 'A', (131, 147), (156, 184)], [0.9524877442595131, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3m3gFH_A.pdb', 'A', (26, 54), (72, 93)], [0.9508817117287728, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2ha8FH_B.pdb', 'B', (76, 94), (105, 133)], [0.9493038496229598, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ualFH_A.pdb', 'A', (85, 108), (115, 139)], [0.9468317754693849, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2qmmFH_A.pdb', 'A', (123, 139), (149, 177)], [0.9456016669142275, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ns5FH_B.pdb', 'B', (67, 94), (104, 127)], [0.935179564620798, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3n4jFH_A.pdb', 'A', (79, 98), (106, 136)], [0.9291058141050534, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3liyFH_A.pdb', 'A', (21, 43), (84, 103)], [0.9243889390566389, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3n4jFH_A.pdb', 'A', (80, 99), (106, 136)], [0.9222126543648004, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1izeFH_A.pdb', 'A', (199, 228), (285, 299)], [0.9218640254619577, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2egvFH_A.pdb', 'A', (158, 179), (186, 212)], [0.9214651831745694, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1bxoFH_A.pdb', 'A', (199, 226), (284, 298)], [0.9166909327691701, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ns5FH_B.pdb', 'B', (68, 96), (104, 127)], [0.9145757635754789, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1qrpFH_E.pdb', 'E', (204, 225), (284, 302)], [0.904167189452212, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2hbwFH_A.pdb', 'A', (14, 35), (46, 69)]]


#unrestricted search, lgth 30:
subChainLength = 30
fileName= root + r'\SubChainPairChars_minmax_computeGI_' + set + '_subChainLength_' + str(subChainLength) + '.txt'
dict_top8000, extremeWrithes_top8000_All, extremeWrithes_top8000_Min, extremeWrithes_top8000_Max  = git.readResultsCcode_closedLoops(inputFileName = fileName, linksAndPokes_b = 0, minMaxOut_b = 1, normalize_b = 1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_subchain_pairs_' + set + '.txt'
#convert structure and then plot
extremeWrithes_top8000 = extremeWrithes_top8000_All, extremeWrithes_top8000_Min, extremeWrithes_top8000_Max
git.histoSubChainPairs_minMax(extremeWrithes_top8000, bins=100, logCount_b = 0, color = 'grey', colorMin = 'lightgrey', colorMax = 'grey', alphaMin = 1.0, alphaMax = 0.8, supTitle_b = 0, titleDistr = 'Distribution of mutual writhe values', addSubplotToFirstPlot_b = 1, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 1, plotExs_b = 0, chainsFile = chainsFile, interval = [-4,-3], plotExsInInt_b =0, stringPattern = '([\S]+)([^\w]+)([\w]+)(.pdb)', subChainLgth =  30, lowerPercentile = 0.005, upperPercentile = 0.995, cutOff = 1.)

git.histoSubChainPairs_minMax(extremeWrithes_top8000, bins=100, logCount_b = 0, color = 'grey', colorMin = 'lightgrey', colorMax = 'grey', alphaMin = 1.0, alphaMax = 0.8, supTitle_b = 0, titleDistr = 'Distribution of mutual writhe values', addSubplotToFirstPlot_b = 1, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 0, plotExs_b = 0, chainsFile = chainsFile, interval = [1.45,3], plotExsInInt_b =1, stringPattern = '([\S]+)([^\w]+)([\w]+)(.pdb)', subChainLgth =  30, lowerPercentile = 0.005, upperPercentile = 0.995)

Top 5 values:
[[1.501886549361687, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3onpFH_A.pdb', 'A', (60, 90), (106, 136)], [1.4752572217483804, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2i6dFH_A.pdb', 'A', (164, 194), (195, 225)], [1.4707961086935146, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ualFH_A.pdb', 'A', (74, 104), (105, 135)], [1.4702035748403834, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1ns5FH_B.pdb', 'B', (61, 91), (92, 122)], [1.4421950104902423, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3o7bFH_A.pdb', 'A', (128, 158), (161, 191)]]
Top 5 lowest values:
[[-1.8403639133143104, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3hmsFH_A.pdb', 'A', (0, 30), (56, 86)], [-1.7588689430139917, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2r99FH_A.pdb', 'A', (70, 100), (102, 132)], [-1.758230731692193, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2cmtFH_A.pdb', 'A', (70, 100), (102, 132)], [-1.7568245181925044, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2wfjFH_A.pdb', 'A', (78, 108), (110, 140)], [-1.7564555970344176, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2cfeFH_A.pdb', 'A', (69, 99), (101, 131)]]


Top 5 values, subchain lgth 15:
[[1.0573438749942181, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3d0nFH_A.pdb', 'A', (139, 154), (205, 220)], [1.0519741463692407, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2nmxFH_A.pdb', 'A', (135, 150), (201, 216)], [1.0347725209649254, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2w2jFH_A.pdb', 'A', (137, 152), (205, 220)], [1.034026323014239, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3ec0FH_B.pdb', 'B', (23, 38), (71, 86)], [1.031666453095544, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1keqFH_B.pdb', 'B', (113, 128), (179, 194)]]
Top 5 lowest values:
[[-1.2467856854466148, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/3cryFH_A.pdb', 'A', (26, 41), (53, 68)], [-1.1964835720203482, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1v30FH_A.pdb', 'A', (22, 37), (41, 56)], [-1.1912083814315673, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/2jh1FH_A.pdb', 'A', (150, 165), (167, 182)], [-1.160257758380901, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1wq8FH_A.pdb', 'A', (53, 68), (79, 94)], [-1.1316111418639048, '/isdata/kroghgrp/tkj375/data/structural/Kinemage/top8000_chains_70/1vkbFH_A.pdb', 'A', (29, 44), (54, 69)]]


#############################################################################
#Twin plot of pymol images, 1bpi and 2cpl, obtained by concatenation:
(actual plot though generated in Pymol)
#############################################################################

import gi_Anomalies as git

root = r'C:\Users\Christian\Bioinformatics\papers\geometric_anomalies_in_folds\plots\for_main_note'

import matplotlib.pyplot as plt
import matplotlib.cbook as cbook
#from mpl_toolkits.axes_grid1 import AxesGrid
#
#grid = AxesGrid(fig, 121,  # similar to subplot(141)
#                    nrows_ncols=(1, 2),
#                    share_all=True,
#                    axes_pad=0.05,
#                    label_mode="0",
#                    )

image_file = cbook.get_sample_data(root + r'\1bpi_unrestricted_search_pymol_resized.png')
#image_file = cbook.get_sample_data(root + r'\1bpi_tube.png')
image = plt.imread(image_file)

fig = plt.figure(figsize = (8,2))
#plt.margins(xmargin =1, ymargin = 1, tight = True)
ax = fig.add_subplot(121)

ax.imshow(image)

#grid[0].imshow(image)

plt.axis('off')  # clear x- and y-axes

image_file = cbook.get_sample_data(root + r'\2cpl_unrestricted_search_pymol_2ndview_resized.png')
#image_file = cbook.get_sample_data(root + r'\2cpl_tube.png')
image = plt.imread(image_file)

ax = fig.add_subplot(122)
ax.imshow(image)

#grid[1].imshow(image)

plt.axis('off')  # clear x- and y-axes
#plt.tight_layout
plt.subplots_adjust(top= 0.95, bottom = 0.05, left = 0.05, right = 0.95, wspace = 0.01)
plt.show()




#############################################################################
# Plots for Supplementary Data, "links paper" 
#############################################################################

import gi_Anomalies as git

#root: as for plots for the paper
 
#Not all these plots were used


#Restricted search:

#top100 set:

root = r'C:\Users\Christian\Sync\Bioinformatics\papers\structural_alignment_by_GIs\results\v10\top100'

set = 'top100'

#Distr's of pokes and links for top100 set in one plot:
#read in results from a run on the top100 set:
#restricted search:
pokeLength = 10
loopLength = 30
#Ex file name: ClosedLoopChars_minmax_computeGI_top100_closedLoopLength_30_closedLoopDist_7.0_pokeLength10
fileName = root + r'\ClosedLoopChars_minmax_computeGI_'+ set + '_closedLoopLength_' +str(loopLength) + '_closedLoopDist_7.0' + '_pokeLength' + str(pokeLength) +'.txt'
dict_top100_cl, links_top100_cl, pokesAll_top100_cl, pokesMin_top100_cl, pokesMax_top100_cl = git.readResultsCcode_closedLoops(inputFileName = fileName, normalize_b = 1, minMaxOut_b =1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_closed_loops_' + set +'.txt'
titleLinks = 'Distribution of writhe values for potential links and pokes of length ' + str(pokeLength) 
titlePokesI = 'Distribution of writhe values for potential pokes of length ' + str(pokeLength) 
titlePokesII = ' writhe values for potential pokes of length ' + str(pokeLength) 
pokes_top100_cl = pokesAll_top100_cl, pokesMin_top100_cl, pokesMax_top100_cl
fig = git.histoClosedLoops_minMax(links_top100_cl, pokes_top100_cl, pokesMinMax_b =1, colorMin = 'lightblue', color = 'blue', colorMax = 'blue', binsLinks=100, binsPokes =100, linksPokesDistrInOnePlot_b =1, linksDistrPlotsInSubPlots_b =0, pokesDistrPlotsInSubPlots_b =0, linksShowTopNr = 100, pokesShowTopNr = 100, cutOffLinks = 0.85, cutOffPokes = 0.8, plotPokeExs_b = 0, plotLinkExs_b = 1, plotLinksTop10_b = 1, plotPokesTop10_b = 0, chainsFile = chainsFile, intervalLinks = [-1.05,-0.95], intervalPokes = [-0.5,-0.4], plotExsInInt_b =0, titleLinks = titleLinks, titlePokesI = titlePokesI, titlePokesII = titlePokesII, stringPattern = '([\S]+)([^\w]+)([\w]+)', lowerPercentile = 0.1, upperPercentile = 0.1)


#to look at writhe ~0  examples:
git.histoClosedLoops_minMax(links_top100_cl, pokes_top100_cl, binsLinks=100, binsPokes =100, colorMin = 'lightblue', color = 'blue', colorMax = 'blue',  elevAzimList = [[15,-45],[160,-45],[-160,-130]], linksPokesDistrInOnePlot_b =0, linksDistrPlotsInSubPlots_b =1, pokesDistrPlotsInSubPlots_b =1,cutOffLinks = 0.9, cutOffPokes = 0.85, linksShowTopNr = 100, pokesShowTopNr = 100, plotLinkExs_b = 0, plotPokeExs_b = 0, plotPokesTop10_b = 0,chainsFile = chainsFile, intervalLinks = [0.105,0.105], intervalPokes = [0.307,0.309], plotExsInInt_b =1, stringPattern = '([\S]+)([^\w]+)([\w]+)', titlePokesI = titlePokesI, titlePokesII = titlePokesII)

#for pos links (change interval as needed):
git.histoClosedLoops_minMax(links_top100_cl, pokes_top100_cl, binsLinks=100, binsPokes =100, colorMin = 'lightblue', color = 'blue', colorMax = 'blue',  elevAzimList = [[15,-45],[160,-45],[-160,-130]], linksPokesDistrInOnePlot_b =0, linksDistrPlotsInSubPlots_b =1, pokesDistrPlotsInSubPlots_b =1,cutOffLinks = 0.9, cutOffPokes = 0.85, linksShowTopNr = 100, pokesShowTopNr = 100, plotLinkExs_b = 0, plotPokeExs_b = 0, plotPokesTop10_b = 0,chainsFile = chainsFile, intervalLinks = [0.5,0.55], intervalPokes = [0.25,0.251], plotExsInInt_b =1, stringPattern = '([\S]+)([^\w]+)([\w]+)', titlePokesI = titlePokesI, titlePokesII = titlePokesII)
#for neg links (change interval as needed):
git.histoClosedLoops_minMax(links_top100_cl, pokes_top100_cl, binsLinks=100, binsPokes =100, colorMin = 'lightblue', color = 'blue', colorMax = 'blue',  elevAzimList = [[15,-45],[160,-45],[-160,-130]], linksPokesDistrInOnePlot_b =0, linksDistrPlotsInSubPlots_b =1, pokesDistrPlotsInSubPlots_b =1,cutOffLinks = 0.9, cutOffPokes = 0.85, linksShowTopNr = 100, pokesShowTopNr = 100, plotLinkExs_b = 0, plotPokeExs_b = 0, plotPokesTop10_b = 0,chainsFile = chainsFile, intervalLinks = [-0.25, -.24], intervalPokes = [0.25,0.251], plotExsInInt_b =1, stringPattern = '([\S]+)([^\w]+)([\w]+)', titlePokesI = titlePokesI, titlePokesII = titlePokesII)

#Similarly for poke lengths 5 and 7.



#top8000 set:

root = r'C:\Users\Christian\Sync\Bioinformatics\papers\structural_alignment_by_GIs\results\v10\top8000'

set = 'top8000'

#Distr's of pokes and links for top8000 set in one plot:
#read in results from a run on the top8000 set:
#restricted search:
pokeLength = 10
loopLength = 30
fileName = root + r'\ClosedLoopChars_minmax_computeGI_'+ set + '_closedLoopLength_' +str(loopLength) + '_closedLoopDist_7.0' + '_pokeLength' + str(pokeLength) +'.txt'
dict_top8000_cl, links_top8000_cl, pokesAll_top8000_cl,  pokesMin_top8000_cl, pokesMax_top8000_cl = git.readResultsCcode_closedLoops(inputFileName = fileName, normalize_b = 1, minMaxOut_b = 1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_closed_loops_' + set +'.txt'
titleLinks = 'Distribution of writhe values for potential links and pokes of length ' + str(pokeLength) 
titlePokesI = 'Distribution of writhe values for potential pokes of length ' + str(pokeLength) 
titlePokesII = ' writhe values for potential pokes of length ' + str(pokeLength) 
pokes_top8000_cl = pokesAll_top8000_cl, pokesMin_top8000_cl, pokesMax_top8000_cl
fig = git.histoClosedLoops_minMax(links_top8000_cl, pokes_top8000_cl, pokesMinMax_b =1, pokesDistrLog_b = 0, colorMin = 'lightblue', color = 'blue', colorMax = 'blue', supTitle_b = 1, binsLinks=100, binsPokes =100, linksPokesDistrInOnePlot_b =1, linksDistrPlotsInSubPlots_b =0, pokesDistrPlotsInSubPlots_b =0, linksShowTopNr = 100, pokesShowTopNr = 100, cutOffLinks = 0.95, cutOffPokes = 0.9, plotPokeExs_b = 0, plotLinkExs_b = 0, plotLinksTop10_b = 0, plotPokesTop10_b = 0, chainsFile = chainsFile, intervalLinks = [-1.1,-.95], intervalPokes = [-0.75,-.74], plotExsInInt_b =0, titleLinks = titleLinks, titlePokesI = titlePokesI, titlePokesII = titlePokesII, lowerPercentile = 0.00001, upperPercentile = 0.99999)


#Separate plot of links and pokes:
pokeLength = 5
loopLength = 30
fileName = root + r'\ClosedLoopChars_minmax_computeGI_'+ set + '_closedLoopLength_' +str(loopLength) + '_closedLoopDist_7.0' + '_pokeLength' + str(pokeLength) +'.txt'
dict_top8000_cl, links_top8000_cl, pokesAll_top8000_cl,  pokesMin_top8000_cl, pokesMax_top8000_cl = git.readResultsCcode_closedLoops(inputFileName = fileName, normalize_b = 1, minMaxOut_b = 1)
chainsFile = root + r'\chains_closed_loops_' + set +'.txt'
titleLinks = 'Distribution of writhe values for potential links'
titlePokesI = 'Distribution of writhe values for potential pokes of length ' + str(pokeLength) 
titlePokesII = '' #' writhe values for potential pokes of length ' + str(pokeLength) 
pokes_top8000_cl = pokesAll_top8000_cl, pokesMin_top8000_cl, pokesMax_top8000_cl
fig = git.histoClosedLoops_minMax(links_top8000_cl, pokes_top8000_cl, pokesMinMax_b =1, pokesDistrLog_b = 1, colorMin = 'lightblue', color = 'blue', colorMax = 'blue', supTitle_b = 1, binsLinks= 50, binsPokes = 50, linksPokesDistrInOnePlot_b =0, linksDistrPlotsInSubPlots_b =1, pokesDistrPlotsInSubPlots_b =1, linksShowTopNr = 100, pokesShowTopNr = 100, cutOffLinks = 0.95, cutOffPokes = 0.9, plotPokeExs_b = 0, plotLinkExs_b = 0, plotLinksTop10_b = 0, plotPokesTop10_b = 0, chainsFile = chainsFile, intervalLinks = [-1.1,-.95], intervalPokes = [-0.75,-.74], plotExsInInt_b =0, titleLinks = titleLinks, titlePokesI = titlePokesI, titlePokesII = titlePokesII, lowerPercentile = 0.00001, upperPercentile = 0.99999)

#Similarly for poke lengths 5 and 7.



#Unrestricted search: 

#top100:

root = r'C:\Users\Christian\Sync\Bioinformatics\papers\structural_alignment_by_GIs\results\v10\top100'

set = 'top100'

#distr of writhe for lgth 15 and 30 in one plot ... plus "interesting examples":
#unrestricted search, lgth 15:
subChainLength = 15
#filename ex: SubChainPairChars_minmax_computeGI_top100_subChainLength_15
fileName= root + r'\SubChainPairChars_minmax_computeGI_' + set + '_subChainLength_' + str(subChainLength) + '.txt'
dict_top100, extremeWrithes_top100_All, extremeWrithes_top100_Min, extremeWrithes_top100_Max = git.readResultsCcode_closedLoops(inputFileName = fileName, linksAndPokes_b = 0, minMaxOut_b = 1, normalize_b = 1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_subChainPairs_' + set + '.txt'
#convert structure and then plot
extremeWrithes_top100 = extremeWrithes_top100_All, extremeWrithes_top100_Min, extremeWrithes_top100_Max
git.histoSubChainPairs_minMax(extremeWrithes_top100, bins=100, color = 'blue', colorMin = 'lightblue', colorMax = 'blue', addSubplotToFirstPlot_b = 1, addSubPlotNr = 121, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 0, plotExs_b = 0, chainsFile = chainsFile, interval = [-8.45,-8.4], plotExsInInt_b =0, stringPattern = '([\S]+)([^\w]+)([\w]+)', subChainLgth =  15, lowerPercentile = 0.05, upperPercentile = 0.95)


# subChainLength 30:
subChainLength = 30
fileName= root + r'\SubChainPairChars_minmax_computeGI_' + set + '_subChainLength_' + str(subChainLength) + '.txt'
dict_top100, extremeWrithes_top100_All, extremeWrithes_top100_Min, extremeWrithes_top100_Max = git.readResultsCcode_closedLoops(inputFileName = fileName, linksAndPokes_b = 0, minMaxOut_b = 1, normalize_b = 1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_subChainPairs_' + set + '.txt'
#convert structure and then plot
extremeWrithes_top100 = extremeWrithes_top100_All, extremeWrithes_top100_Min, extremeWrithes_top100_Max
git.histoSubChainPairs_minMax(extremeWrithes_top100, bins=100, color = 'blue', colorMin = 'lightblue', colorMax = 'blue', addSubplotToFirstPlot_b = 1, addSubPlotNr = 122, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 0, plotExs_b = 0, chainsFile = chainsFile, interval = [-11,-10], plotExsInInt_b =0, stringPattern = '([\S]+)([^\w]+)([\w]+)', subChainLgth =  30, lowerPercentile = 0.05, upperPercentile = 0.95)

#To show only two projections of examples:
elevAzimList = [[15,-45],[160,-45]]
git.histoSubChainPairs_minMax(extremeWrithes_top100, bins=100, elevAzimList = elevAzimList, color = 'blue', colorMin = 'orange', colorMax = 'blue', addSubplotToFirstPlot_b = 1, addSubPlotNr = 121, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 1, plotExs_b = 0, chainsFile = chainsFile, interval = [-8.45,-8.4], plotExsInInt_b =0, stringPattern = '([\S]+)([^\w]+)([\w]+)', subChainLgth =  15, lowerPercentile = 0.05, upperPercentile = 0.95)


#top8000:

root = r'C:\Users\Christian\Sync\Bioinformatics\papers\structural_alignment_by_GIs\results\v10\top8000'

set = 'top8000'

#unrestricted search, lgth 15:
#distr of writhe for lgth 15 and 30 in one plot ... plus "interesting examples":
subChainLength = 15
#filename ex: SubChainPairChars_minmax_computeGI_top8000_subChainLength_15
fileName= root + r'\SubChainPairChars_minmax_computeGI_' + set + '_subChainLength_' + str(subChainLength) + '.txt'
dict_top8000, extremeWrithes_top8000_All, extremeWrithes_top8000_Min, extremeWrithes_top8000_Max = git.readResultsCcode_closedLoops(inputFileName = fileName, linksAndPokes_b = 0, minMaxOut_b = 1, normalize_b = 1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_subchain_pairs_' + set + '.txt'
#convert structure and then plot
extremeWrithes_top8000 = extremeWrithes_top8000_All, extremeWrithes_top8000_Min, extremeWrithes_top8000_Max
git.histoSubChainPairs_minMax(extremeWrithes_top8000, bins=100, color = 'blue', colorMin = 'lightblue', colorMax = 'blue', addSubplotToFirstPlot_b = 1, addSubPlotNr = 121, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 1, plotExs_b = 0, chainsFile = chainsFile, interval = [-1.1,-1], plotExsInInt_b =0, subChainLgth =  subChainLength, lowerPercentile = 0.001, upperPercentile = 0.999, few_xticks_b = 1)


# subChainLength 30:
subChainLength = 30
fileName= root + r'\SubChainPairChars_minmax_computeGI_' + set + '_subChainLength_' + str(subChainLength) + '.txt'
dict_top8000, extremeWrithes_top8000_All, extremeWrithes_top8000_Min, extremeWrithes_top8000_Max = git.readResultsCcode_closedLoops(inputFileName = fileName, linksAndPokes_b = 0, minMaxOut_b = 1, normalize_b = 1)
#sort the results and plot distributions (parts of) and link/poke examples (outside cutOff's)
chainsFile = root + r'\chains_subchain_pairs_' + set + '.txt'
#convert structure and then plot
extremeWrithes_top8000 = extremeWrithes_top8000_All, extremeWrithes_top8000_Min, extremeWrithes_top8000_Max
git.histoSubChainPairs_minMax(extremeWrithes_top8000, bins=100, color = 'blue', colorMin = 'lightblue', colorMax = 'blue', addSubplotToFirstPlot_b = 1, addSubPlotNr = 122, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 1, plotExs_b = 0, chainsFile = chainsFile, interval = [-1.1,-1.0], plotExsInInt_b =0, subChainLgth = subChainLength, lowerPercentile = 0.001, upperPercentile = 0.999, few_xticks_b = 1)

#Only two projections in examples:
elevAzimList = [[15,-45],[160,-45]]
git.histoSubChainPairs_minMax(extremeWrithes_top8000, bins=100, elevAzimList = elevAzimList, color = 'blue', colorMin = 'lightblue', colorMax = 'blue', addSubplotToFirstPlot_b = 0, addSubPlotNr = 122, distrPlotsInSubPlots_b =0, showTopNr = 10, plotTop10_b = 1, plotExs_b = 0, chainsFile = chainsFile, interval = [-1.1,-1.0], plotExsInInt_b =0, subChainLgth = subChainLength, lowerPercentile = 0.05, upperPercentile = 0.95, few_xticks_b = 1)


'''


import matplotlib.pyplot as plt
import numpy as np
from scipy import stats

from pymol import cmd

import re

import os

#import scipy.stats as stats

#ignore warnings
import warnings
warnings.filterwarnings("ignore")

#import git modules:
#from git_utils import *
#from git_bf import *

#from Bio import PDB

#parser = PDB.PDBParser()

import csv


####################################################################################
# Code for handling search for links and pokes: Plots of distributions and examples
####################################################################################

#Util for replacing server-path with pc-path in file:
def replacePath(inputFileName, outputFileName, oldPath, newPath, replaceEntryAt = 0):
    
#    os.path.join(newPath, '\'')    
    
    with open(outputFileName, 'w') as newFile:
        
        with open(inputFileName, 'r') as CresultsTxt:
            Cresults = csv.reader(CresultsTxt, delimiter = ';')
            writer = csv.writer(newFile, delimiter=';')
    
            for row in Cresults:
               s = row[replaceEntryAt]         
               row[replaceEntryAt] = re.sub(oldPath, newPath , row[replaceEntryAt]) #replaces the old-path with the new-path
               if row[replaceEntryAt] != s:
                   print s, row[replaceEntryAt]
               writer.writerow(row)
            
            
    

def readResultsCcode_chains(inputFileName):
    '''Reads in the chains in terms of 3d-coordinates of the C-alpha trace from file 
    containing chain-data as it is output by the C-code (with write_chain_b = 1).
    
    Output: dictionary mapping each pdb-file name and chain id (covered in the
    input) to the (ordered) list of xyz-coordinates of the chain of C-alphas and 
    the corresponding list of segment coordinates (of C-alpha-to-C-alpha segments).
    More precisely: 
    pdb-file -> chain id -> [[list of chain coords],[list of [segment start, segment end] coords]]
    
    Input: file name (path to file) of file containing the results from the write out
    of the chains by means of the C-code (GISA).
    '''
    
    outDict = {}
    
    pdb_file = ''
        
    with open(inputFileName, 'r') as CresultsTxt:
        Cresults = csv.reader(CresultsTxt, delimiter = ';')
        for row in Cresults:
            if row[0] == "PDBfile":
                pdb_file = row[3]
                chainId = row[5]
                if not(outDict.has_key(pdb_file)):
                    outDict[pdb_file] = {}
                if not(outDict[pdb_file].has_key(chainId)):
                    outDict[pdb_file][chainId]  =[]
            elif row[0] == "Index":
                continue
            else:
                x = float(row[1])
                y = float(row[2])
                z = float(row[3])
                resNr = int(row[4])
                outDict[pdb_file][chainId].append([[x,y,z], resNr])

    #generate for each entry the corresponding segments list:
    for pdb_file in outDict.keys():
        for chainId in outDict[pdb_file].keys():
            segs = []
            chain = outDict[pdb_file][chainId]
            for i in range(len(outDict[pdb_file][chainId])-1):
                startPt = chain[i][0]
                endPt = chain[i+1][0]
                segs.append([startPt, endPt])
            outDict[pdb_file][chainId] = [chain,segs] 
                
    return outDict
    
#the following fct is extended slightly from thesis-version in that it is here possible
#to also fetch the min and max values in separate lists:
def readResultsCcode_closedLoops(inputFileName, 
                                 linksAndPokes_b = 1, 
                                 minMaxOut_b = 0, 
                                 multiInv_b = 0, 
                                 normalize_b = 0):
    '''Read in results obtained by running the C-code for getting info on 
    closed loop characteristics (search for links and "pokes").

    Output: dictionary mapping each pdb-file (name given as path to file) to
    dictionary containing the results: this dictionary maps a description ("link" 
    or "poke") to a closed loop (given as a pair of indices) to another closed 
    loop or sub chain (also given by a pair of indices) which is then finally 
    mapped to the writhe value (ie  the writhe of the pair (closed loop, closed
    loop/sub chain).

    Input:
    inputFileName: path to results file.
    linksAndPokes_b: if 1 the fct will try to find data for links and pokes (restricted search)
    in the input file and return these; else the fct will look for sub-chain 
    results (unrestricted search) and return the extreme of these per PDB-file in input (default 1).
    minMaxOut_b: if set to 1 the results for subChainPairs (ie linksAndPokes_b != 1)
    will include separate lists of the min and the max values; else only all values
    are returned.
    multiInv_b (only for linksAndPokes_b != 1): if the input for subChainPairs cover
    a set of invariants (rather than just the writhe), and when setting this parameter to 
    1, the outputted values can be provided in dictionaries, mapping the invariant 
    name to the output for that invariant (with output structured as for the writhe).
    normalize_b (default 0): if set to 1, the order 1 Gauss Integral values will be normlized
    by 4*pi for links and pokes (when linksAndPokes_b == 1) and for pairs of sub-chains
    (linksAndPokes_b != 1 and multiInv_b !=1).
    replaceKeyDataRoot_b: if the c-code was run on a different server, the pdb-files there
    must be copied to the machine on which you run this python and the keys in the dictionaries
    must be replaced correspondingly.
    oldKeyDataRoot: the path to the pdb-files on the server on which the c-code was run
    newKeyDataRoot: the path to the pdb-files on this machine (on which you run this python script).'''

#    readOrder = ["PDB_file", 
#          "chain id",
#		    "description",
#			"closed loop index 1",
#           "closed loop index 2",
#			"sub chain index 1",
#           "sub chain index 2",
#           "I12"]
          
    outDict = {}
        
    with open(inputFileName, 'r') as CresultsTxt:
        Cresults = csv.reader(CresultsTxt, delimiter = ';')
        for row in Cresults:

            idxs_loop =  (int(row[3]),int(row[4]))
#            print idxs_loop
            idxs_subChain = (int(row[5]),int(row[6]))
#            print idxs_subChain
            
            
            if not(outDict.has_key(row[0])): #key: filename?
                outDict[row[0]] = {}
#                print "file:", row[0]

                    
            if not(outDict[row[0]].has_key(row[1])): #key: chain id?
                outDict[row[0]][row[1]] = {}
            if not(outDict[row[0]][row[1]].has_key(row[2])): #key: description? (link/poke)
                outDict[row[0]][row[1]][row[2]] = {}
                
            if not(outDict[row[0]][row[1]][row[2]].has_key( idxs_loop)):
                outDict[row[0]][row[1]][row[2]][idxs_loop] = {}
            if not(outDict[row[0]][row[1]][row[2]][idxs_loop].has_key( idxs_subChain)):
                outDict[row[0]][row[1]][row[2]][idxs_loop][idxs_subChain] = row[7]
                

    if linksAndPokes_b == 1:
        #gather all results from potential links (ie closed loop pairs) and
        #gather all results from potential pokes (ie (closed loop, sub chain) pairs):
        linkValues = []
        pokeValues = []
        pokeValuesMin = []
        pokeValuesMax = []
    
        
        for file_key in outDict.keys():
            for chainId in outDict[file_key].keys():
                maxVal = -1e+20 #for pokes: we want to keep which potential poke has the max and which has the min writhe values
                minVal = 1e+20 #do
                maxAt_loop_key = [] #do
                maxAt_subChain_key = [] #do
                minAt_loop_key = [] #do
                minAt_subChain_key = [] #do
                for type_key in outDict[file_key][chainId].keys():
                    for loop_key in outDict[file_key][chainId][type_key].keys():
                        for subChain_key in outDict[file_key][chainId][type_key][loop_key].keys():
                            val = float(outDict[file_key][chainId][type_key][loop_key][subChain_key])
                            if normalize_b ==1:
                                val = float(val/(4*np.pi))
                            if (minMaxOut_b == 1 and type_key == 'poke'):
                                #keep the val etc if max or min:
                                if val > maxVal:
                                    maxVal = val
                                    maxAt_loop_key = loop_key
                                    maxAt_subChain_key = subChain_key
                                if val < minVal:
                                    minVal = val
                                    minAt_loop_key = loop_key
                                    minAt_subChain_key = subChain_key
                            if type_key == 'link':
                                linkValues.append([val, file_key, chainId, loop_key, subChain_key] )
                            elif type_key == 'poke':
                                pokeValues.append([val, file_key, chainId, loop_key, subChain_key])    
                    if (minMaxOut_b == 1 and type_key == 'poke'):
                        pokeValuesMax.append([maxVal, file_key, chainId, maxAt_loop_key, maxAt_subChain_key])    
                        pokeValuesMin.append([minVal, file_key, chainId, minAt_loop_key, minAt_subChain_key])         
        if minMaxOut_b == 1:
            return outDict, linkValues, pokeValues, pokeValuesMin, pokeValuesMax
        else:
            return outDict, linkValues

    else: #if linksAndPokes_b != 1: fetch the subChain results
    
        if multiInv_b !=1:
            extremeWritheValues = []
            extremeWritheValuesMin = []
            extremeWritheValuesMax = []
    
            for file_key in outDict.keys():
                for chainId in outDict[file_key].keys():
                    maxVal = -1e+20 #for sub-chain pairs: we want to fetch only the max and min writhe values
                    minVal = 1e+20 #do
                    maxAt_loop_key = [] #do
                    maxAt_subChain_key = [] #do
                    minAt_loop_key = [] #do
                    minAt_subChain_key = [] #do
                    for type_key in outDict[file_key][chainId].keys():
                        for loop_key in outDict[file_key][chainId][type_key].keys():
                            for subChain_key in outDict[file_key][chainId][type_key][loop_key].keys():
                                val = float(outDict[file_key][chainId][type_key][loop_key][subChain_key])
                                if normalize_b ==1:
                                    val = float(val/(4*np.pi))
                                if type_key == 'subChainPair':
                                    #keep the val etc if max or min:
                                    if val > maxVal:
                                        maxVal = val
                                        maxAt_loop_key = loop_key
                                        maxAt_subChain_key = subChain_key
                                    if val < minVal:
                                        minVal = val
                                        minAt_loop_key = loop_key
                                        minAt_subChain_key = subChain_key
                        if maxVal < -10:
                            print "maxVal < -10 for: %s" % file_key
                        if type_key == 'subChainPair':
                            extremeWritheValues.append([maxVal, file_key, chainId, maxAt_loop_key, maxAt_subChain_key])    
                            extremeWritheValues.append([minVal, file_key, chainId, minAt_loop_key, minAt_subChain_key])  
                            extremeWritheValuesMax.append([maxVal, file_key, chainId, maxAt_loop_key, maxAt_subChain_key])    
                            extremeWritheValuesMin.append([minVal, file_key, chainId, minAt_loop_key, minAt_subChain_key])  
            if minMaxOut_b == 1:
                return outDict, extremeWritheValues, extremeWritheValuesMin, extremeWritheValuesMax
            else:
                return outDict, extremeWritheValues
        
        if multiInv_b ==1:
            
            extremeWritheValues = {}
            extremeWritheValuesMin = {}
            extremeWritheValuesMax = {}
    
            for file_key in outDict.keys():
                for chainId in outDict[file_key].keys():
                    for type_key in outDict[file_key][chainId].keys():
                        maxVal = -1e+20 #for sub-chain pairs: we want to fetch only the max and min writhe values
                        minVal = 1e+20 #do
                        maxAt_loop_key = [] #do
                        maxAt_subChain_key = [] #do
                        minAt_loop_key = [] #do
                        minAt_subChain_key = [] #do
                        for loop_key in outDict[file_key][chainId][type_key].keys():
                            for subChain_key in outDict[file_key][chainId][type_key][loop_key].keys():
                                val = float(outDict[file_key][chainId][type_key][loop_key][subChain_key])
                                #keep the val etc if max or min:
                                if val > maxVal:
                                    maxVal = val
                                    maxAt_loop_key = loop_key
                                    maxAt_subChain_key = subChain_key
                                if val < minVal:
                                    minVal = val
                                    minAt_loop_key = loop_key
                                    minAt_subChain_key = subChain_key 
                        if not(extremeWritheValues.has_key(type_key)):
                            extremeWritheValues[type_key] = []
                            extremeWritheValuesMin[type_key] = []
                            extremeWritheValuesMax[type_key] = []
                        extremeWritheValues[type_key].append([maxVal, file_key, chainId, maxAt_loop_key, maxAt_subChain_key])    
                        extremeWritheValues[type_key].append([minVal, file_key, chainId, minAt_loop_key, minAt_subChain_key])  
                        extremeWritheValuesMax[type_key].append([maxVal, file_key, chainId, maxAt_loop_key, maxAt_subChain_key])    
                        extremeWritheValuesMin[type_key].append([minVal, file_key, chainId, minAt_loop_key, minAt_subChain_key])  
            if minMaxOut_b == 1:
                return outDict, extremeWritheValues, extremeWritheValuesMin, extremeWritheValuesMax
            else:
                return outDict, extremeWritheValues        
        


          
#Version of histoClosedLoops allowing to plot min/max separately for pokes
#To use this fct use readResultsCcode_closedLoops as follows:
#linkValues, pokeValuesAll, pokeValuesMin, pokeValuesMax  = readResultsCcode_closedLoops(inputFileName, linksAndPokes_b = 1, minMaxOut_b = 0 ...[other params])
#Then set pokeValues = pokeValuesAll, pokeValuesMin, pokeValuesMax
#and fire off histoClosedLoops_minMax(linkValues, pokeValues, ...)
#See some concrete examples in the Usage section at the beginning of this file
def histoClosedLoops_minMax(linkValues, 
                     pokeValues, 
                     pokesMinMax_b = 1, 
                     binsLinks = 10, 
                     binsPokes = 10, 
                     pokesDistrLog_b = 0,
                     linksShowTopNr = 100, 
                     pokesShowTopNr =100, 
                     cutOffLinks = 0.9, 
                     cutOffPokes = 0.8, 
                     lowerPercentile = 0.01,
                     upperPercentile = 0.99,
                     chainsFile = '', 
                     inFig = '',
                     titleDistr = 'Restricted search',
                     linksPokesDistrInOnePlot_b = 0,
                     linksDistrPlotsInSubPlots_b = 0, 
                     pokesDistrPlotsInSubPlots_b = 0, 
                     plotLinkExs_b = 0, 
                     plotPokeExs_b = 0 , 
                     plotLinksTop10_b = 0, 
                     plotPokesTop10_b = 0,
                     titleLinks = 'Distribution of writhe values for potential links',
                     titlePokesI = 'Distribution of writhe values for potential pokes',
                     titlePokesII = ' writhe values for potential pokes',
                     color = 'blue',
                     colorMin = 'lightgrey',
                     colorMax = 'grey',
                     alphaMin = 1.0,
                     alphaMax = 0.8,
                     supTitle_b = 1,
                     fontsizeLabel = "large",
                     fontsizeSubTitle = "large",
                     fontsizeTitle = "large",
                     intervalLinks = [2,3],
                     intervalPokes = [2,3],
                     plotExsInInt_b = 0, 
                     elevAzimList =  [[15,-90], [15,0], [90,0]], 
                     color1 = 'red', 
                     markerAtom1 = 'o', 
                     markerLine1 = '-', 
                     color2 = 'blue', 
                     markerAtom2 = 'o', 
                     markerLine2 = '-', 
                     stringPattern = '([\S]+)([^\w]+)([\w]+)\.([\w]+)',
                     use_pymol_b = 0,
                     plotDistributions_b = 1):
    '''Plots histograms of the distributions of the writhe numbers from potential
    links and "pokes". 
    Makes 3d plots of cases for which the writhe is outside the interval [-cutOff, cutOff], i.e. 
    of the "exectional writhe" cases; the relevant closed loops/subChains are highlighted in each case. 
    Examples having a writhe value in top10 of all (in absolute value) of examples having a writhe inside 
    a set interval (intervalLinks and intervalPokes) can also be chosen (use plotLinksTop10_b = plotPokesTop10_b 
    = 1 and plotExsInInt_b = 1, respectively).

    Input:
     linkValues and pokeValues: data for the potential links/pokes as output by readResultsCcode_closedLoops; the structure is
     
     linkValues, pokeValuesAll, pokeValuesMin, pokeValuesMax  = readResultsCcode_closedLoops(...) 

     Then let pokeValues pokeValuesAll, pokeValuesMin, pokeValuesMax (see also usage section for explicit examples).  
     
     pokesMinMax_b (1): plots the distributions of the max-values and of the min-values in one (diff colors, colorMin and colorMax, can be chosen) 
     binsLinks (10): number of bins in links-distribution plot 
     binsPokes (10): number of bins in pokes-distribution plot   
     pokesDistrLog_b (0): if set to 1 the frequency (y-axis) in the distr's will be done by log(count +1)
     linksShowTopNr (100): plot upper and lower tails (count 100) in links' distr's  
     pokesShowTopNr (100): plot upper and lower tails (count 100) in pokes' distr's  
     cutOffLinks (0.9): links with an abs value of writhe above this scalar can be shown as 3d-plots (set plotLinksEx_b = 1) 
     cutOffPokes (0.8): pokes with an abs value of writhe above this scalar can be shown as 3d-plots (set plotPokesEx_b = 1)  
     lowerPercentile (0.01): counts for this percentile will be printed on the screen (lower: self explanatory)
     upperPercentile (0.99): as lowerPercentile 
     chainsFile (''): name (path to) of file holding the data of the chains needed for 3d-plotting out the examples. The structure
     of this file must be as output of C-code; the file will be read in by readResultsCcode_chains so see there for more 
     inFig (''): a list of (open) figures; if provided the first in the list is fetched and the plot of the distribution
     of writhes for potential links is added as a subplot next to that figure. So can be used to lot two distr's side-by-side. 
     titleDistr ('Restricted search'): "Super" title of distribution plot 
     supTitle_b (1): if set to 0 no super title will be printed (see titleDistr)
     linksPokesDistrInOnePlot_b (0): if set to 1 links and pokes distrs's will be done in one plot
     linksDistrPlotsInSubPlots_b (0): if set to 1 links distrs's will be done in one plot (tails plots added on the sides)
     pokesDistrPlotsInSubPlots_b (0): if set to 1 pokes distrs's will be done in one plot (tails plots added on the sides)
     plotLinkExs_b (0): see cutOffLinks
     plotPokeExs_b (0): see cutOffPokes/cutOffLinks 
     plotLinksTop10_b (0): if set to 1, the links with in top10 wrt the abs value of writhe will be shown as 3d-plots (the 5 top positives and the 5 top negatives)
     plotPokesTop10_b (0): if set to 1, the pokes with in top10 wrt the abs value of writhe will be shown as 3d-plots (the 5 top positives and the 5 top negatives)
     intervalLinks ([2,3]): see plotExsInInt_b; the number of potential links having a writhe in this interval is shown 
     intervalPokes ([2,3]): seeplotExsInInt_b; the number of potential pokes having a writhe in this interval is shown 
     plotExsInInt_b (0): if set to 1 the potential links and pokes having writhe values in intervalLinks and in intervalPokes will be shown (3d-plots) 
     titleLinks ('Distribution of writhe values for potential links'): title on links distr plot
     titlePokesI ('Distribution of writhe values for potential pokes'): title on pokes distr plot
     titlePokesII (' writhe values for potential pokes'): last part of title on zoom-in on tails of distr of pokes
     color ('blue'): color of bars in distr plots (if colorMin, colorMax are not used)
     colorMin ('lightgrey'): see pokesMinMax_b
     colorMax ('grey'): see pokesMinMax_b
     alphaMin (1.0): transparency factor in min/max distr plots (min-part)
     alphaMax (0.8): transparency factor in min/max distr plots (max-part)
     fontsizeLabel ("large"): font size of plot labels
     fontsizeSubTitle ("large"): font size of plot sub-titles
     fontsizeTitle ("large"): font size of plot super title (see titleDistr)
     elevAzimList ([[15,-90], [15,0], [90,0]]): list of elevation and azimutal angles used in 3d-plots. The length of the list determines the number of 
     subplots in the 3d-plots. 
     color1 ('red'): color of first high-lighted chain-segment in 3d-plot (each plotted example consists in two segments, a closed loop and a closed loop/short sub-chain)  
     markerAtom1 ('o'): marker of C-alpha atoms in first high-lighted chain-segment in 3d-plot (see also color1) 
     markerLine1 ('-'): marker of C-alpha atoms not in first or second high-lighted chain-segment in 3d-plot (see also color1)
     color2 ('blue'): color of second high-lighted chain-segment in 3d-plot (see also color1) 
     markerAtom2 ('o'): marker of C-alpha atoms in second high-lighted chain-segment in 3d-plot (see also color1)  
     markerLine2 ('-'): marker of C-alpha atoms not in first or second high-lighted chain-segment in 3d-plot (see also color1)
     stringPattern ('([\S]+)([^\w]+)([\w]+)\.([\w]+)'): string pattern o path to pdb-file; used for extracting the pdb-id for use in
     3d-plots
     use_pymol_b (0):  must be set to 1 if the function is executed in Pymol
     plotDistributions_b (1): if set to 0 no distributions are plotted (handy when running the function in Pymol, since it suppresses the additional distribution plots)
    '''


    #plot distributions of all values:
    #links
    linkValuesAll = [linkValues[i][0] for i in range(len(linkValues)) ]

    linkValues.sort(reverse = True) #21-Aug-2016    
    #We want first to find the lower and upper percentiles as desired (approx'ly):
    L = len(linkValuesAll)
    print "Number of potential links: %d" % L

    #Check if the percentiles make sense with the number of potential links -- if not: return:
    if (lowerPercentile < 1./L or 1 - upperPercentile < 1./L):
        print "Not all the set percentiles make sense, since there are only %d potential links" % L
        return
    
    #sort the values:
    linkValuesAll.sort(reverse = False)
    #find indexes "surrounding" the percentiles:
    il_lowerPct = int(np.floor(L*lowerPercentile))
    ir_lowerPct = min(il_lowerPct +1,L-1) #L-1: last index in linkValuesAll
    print "(Links) idx's left and right of lower percentile %f: %d, %d with values: %f, %f" % (lowerPercentile, il_lowerPct, ir_lowerPct, linkValuesAll[il_lowerPct], linkValuesAll[ir_lowerPct] )
    il_upperPct = int(np.floor(L*upperPercentile))
    ir_upperPct = min(il_upperPct +1, L-1) #L-1: last index in linkValuesAll
    print "(Links) idx's left and right of upper percentile %f: %d, %d with values: %f, %f" % (upperPercentile, il_upperPct, ir_upperPct, linkValuesAll[il_upperPct], linkValuesAll[ir_upperPct] )
    #let the desired percentiles be set as the weighted average over the values left and right of the percentile:
    lowerPct = (L*lowerPercentile- il_lowerPct)*linkValuesAll[ir_lowerPct] + (ir_lowerPct - L*lowerPercentile)*linkValuesAll[il_lowerPct]
    upperPct = (L*upperPercentile- il_upperPct)*linkValuesAll[ir_upperPct] + (ir_upperPct - L*upperPercentile)*linkValuesAll[il_upperPct]
    print "(Links) Lower percentile %f pct at: %f; upper percentile %f pct at: %f" % (100*lowerPercentile, lowerPct, 100*upperPercentile, upperPct)

    
    kur = stats.kurtosis(linkValuesAll)
    print "(Links) Kurtosis is: %f" % kur
        
    if plotDistributions_b == 1:    
        
        #a straight histo plot: plt.hist(linkValuesAll, bins = binsLinks)
        #But: we want to transform the counts to log10(1+count)
        #Can be done like this:
    #    counts, bins, patches = plt.hist(linkValuesAll, bins = binsLinks)
    #    plt.close()
        counts, bins = np.histogram(linkValuesAll, bins = binsLinks) 
    #    print counts
    #    print bins
    #    print "len bins:%d" % len(bins)
        #bin mid points
        midPts = [float(bins[i] + bins[i+1])/2 for i in range(len(bins)-1)]
        #width of bins:
        w = [float(bins[i+1] - bins[i]) for i in range(len(bins)-1)]
        #then make a bar plot:
        if linksPokesDistrInOnePlot_b == 1:
            fig1, ax1 = plt.subplots(figsize = (14,8), nrows = 1, ncols = 2)
            ax1_1 = ax1[0]
            titleDistr = 'Links'
            titleLinks = titleLinks
        elif linksDistrPlotsInSubPlots_b == 1:
            fig1, ax1 = plt.subplots(figsize = (14,8), nrows = 1, ncols = 3)
            ax1_1 = ax1[1]
            titleDistr = 'All'
        elif linksDistrPlotsInSubPlots_b == 2:
            if not(inFig): 
                fig1 = plt.figure(figsize = (14,8))
                ax1_1 = fig1.add_subplot(121)
                titleDistr = titleDistr
            else:
                fig1 = plt.figure(num = 1) #fetches the first of the list of existing figures
                ax1_1 = fig1.add_subplot(122)
                titleDistr = titleDistr
    #        fig1, ax1 = plt.subplots(figsize = (14,8), nrows = 1, ncols = 2)
    #        ax1_1 = ax1[0]
        else:
            fig1, ax1 = plt.subplots(figsize = (14,8), nrows = 1, ncols = 1)
            ax1_1 = ax1        
            titleDistr = 'All'
    
           
        ax1_1.bar([bins[i] for i in range(len(bins)-1)], np.log10(1+counts), width = w, color = color, fill = True, alpha = 0.8)
        #add a little x-axis to the left and to the right (multiples of 0.25):
        xLimPos = -1.00
        while(xLimPos - bins[len(bins)-1] < 0):
            xLimPos += 0.25
        xLimNeg = 1.00  
        while(bins[0] - xLimNeg < 0):
            xLimNeg -= 0.25
        ax1_1.set_xlim(xLimNeg,xLimPos)
#        ax1_1.set_ylim(0,7)
        ax1_1.set_xlabel('writhe', fontsize = fontsizeLabel)
        ax1_1.set_ylabel('log(1+count)', fontsize = fontsizeLabel)
        ax1_1.tick_params(labelsize = fontsizeLabel)
        
        titleLinks = titleLinks
        if supTitle_b ==1:
            fig1.suptitle(titleLinks, fontsize = fontsizeTitle)
        ax1_1.set_title(titleDistr, fontsize = fontsizeSubTitle)
    
    
#        linkValues.sort(reverse = True) #21-Aug-2016
    
    
        #plot top and bottom link values (unless links and pokes distr are made in one plot)
        if linksPokesDistrInOnePlot_b != 1:
            
            #linkValues.sort(reverse = True) 21-Aug-2016

            linksShowTopNr = min(linksShowTopNr, L)            
            
            #plot top values
            if linksDistrPlotsInSubPlots_b ==1:
                ax1_2 = ax1[2] 
            elif linksDistrPlotsInSubPlots_b != 2:
                fig1, ax1 = plt.subplots(figsize = (14,8), nrows = 1, ncols = 1)
                ax1_2 = ax1
             
            if linksDistrPlotsInSubPlots_b != 2:
                selectedLinkValuesTop = [linkValues[i][0] for i in range(linksShowTopNr) ]
                ax1_2.hist(selectedLinkValuesTop, bins = binsLinks, color = color, fill = True, alpha = 0.8)
                titleLinks = 'Upper ' + str(len(selectedLinkValuesTop)) #+ ' highest writhe values for potential links'
                ax1_2.set_title(titleLinks, fontsize = fontsizeSubTitle)
                #ax1_2.set_xlabel('writhe', fontsize = fontsizeLabel)
                #set every 2nd xtick:
                j= 0
                xticks = ax1_2.get_xticks()
                xticksNew = []
                while(2*j < len(xticks)):
                    xticksNew.append(xticks[2*j])
                    j +=1
                ax1_2.set_xticks(xticksNew)
                ax1_2.set_ylabel('count', fontsize = fontsizeLabel)
                ax1_2.tick_params(labelsize = fontsizeLabel)
        
              
            #plot bottom link values
            if linksDistrPlotsInSubPlots_b ==1:
                ax1_3 = ax1[0] 
            elif linksDistrPlotsInSubPlots_b != 2:
                fig1, ax1 = plt.subplots(figsize = (14,8), nrows = 1, ncols = 1)
                ax1_3 = ax1 
        
            if linksDistrPlotsInSubPlots_b != 2:
                selectedLinkValuesBottom = [linkValues[::-1][i][0] for i in range(linksShowTopNr) ] #linkValues were sorted in reverse above
                ax1_3.hist(selectedLinkValuesBottom, bins = binsLinks, color = color, fill = True, alpha = 0.8)
                titleLinks = 'Lower ' + str(len(selectedLinkValuesBottom)) #+ ' lowest writhe values for potential links'
                ax1_3.set_title(titleLinks, fontsize = fontsizeSubTitle)
                #ax1_3.set_xlabel('writhe', fontsize = fontsizeLabel)
                #set every 2nd xtick:
                j= 0
                xticks = ax1_3.get_xticks()
                xticksNew = []
                while(2*j < len(xticks)):
                    xticksNew.append(xticks[2*j])
                    j +=1
                ax1_3.set_xticks(xticksNew)
                ax1_3.set_ylabel('count', fontsize = fontsizeLabel)
                ax1_3.tick_params(labelsize = fontsizeLabel)

    ########################    
    #Pokes
    ########################    
        
    #Read in the data
    pokeValues, pokeValuesMin, pokeValuesMax = pokeValues    
        
    pokeValues.sort(reverse = True) #21-Aug-2016    
    pokeValuesAll = [pokeValues[i][0] for i in range(len(pokeValues))]
    print "Min writhe for pokes:%d" % min(pokeValuesAll)
    print "Max writhe for pokes:%d" % max(pokeValuesAll) 
    if pokesMinMax_b == 1:         
        pokeValuesMin = [pokeValuesMin[i][0] for i in range(len(pokeValuesMin)) ]
        pokeValuesMax = [pokeValuesMax[i][0] for i in range(len(pokeValuesMax)) ]

    #We want first to find the lower and upper percentiles as desired (approx'ly):
    L = len(pokeValuesAll)
    print "Number of potential pokes: %d" % L
    
    #Check if the percentiles make sense with the number of potential pokes -- if not: return:
    if (lowerPercentile < 1./L or 1 - upperPercentile < 1./L):
        print "Not all the set percentiles make sense, since there are only %d potential pokes" % L
        return
        
    #sort the values:
    pokeValuesAll.sort(reverse = False)
    #find indexes "surrounding" the percentiles:
    il_lowerPct = int(np.floor(L*lowerPercentile))
    ir_lowerPct = il_lowerPct +1 # equals int(np.ceil(L*0.01)) unless L*0.01 is integral
    print "(Pokes) idx's left and right of lower percentile %f: %d, %d with values: %f, %f" % (lowerPercentile, il_lowerPct, ir_lowerPct, pokeValuesAll[il_lowerPct], pokeValuesAll[ir_lowerPct] )
    il_upperPct = int(np.floor(L*upperPercentile))
    ir_upperPct = il_upperPct +1 # equals int(np.ceil(L*0.99)) unless L*0.99 is integral
    print "(Pokes) idx's left and right of upper percentile %f: %d, %d with values: %f, %f" % (upperPercentile, il_upperPct, ir_upperPct, pokeValuesAll[il_upperPct], pokeValuesAll[ir_upperPct] )
    #let the desired percentiles be set as the weighted average over the values left and right of the percentile:
    lowerPct = (L*lowerPercentile- il_lowerPct) *pokeValuesAll[ir_lowerPct] + (ir_lowerPct - L*lowerPercentile)*pokeValuesAll[il_lowerPct]
    upperPct = (L*upperPercentile- il_upperPct)*pokeValuesAll[ir_upperPct] + (ir_upperPct - L*upperPercentile)*pokeValuesAll[il_upperPct]
    print "(Pokes) Lower percentile %f pct at: %f; upper percentile %f pct at: %f" % (100*lowerPercentile, lowerPct, 100*upperPercentile, upperPct)

    
 
    if plotDistributions_b == 1:   

        #straight histo plot: plt.hist(pokeValuesAll, bins = binsPokes)
        #But: we want to transform the counts to log10(1+count)
        #Can be done like this:
    #    counts, bins, patches = plt.hist(pokeValuesAll, bins = binsPokes)
    #    plt.close()
    #    #bin mid points
    #    midPts = [float(bins[i] + bins[i+1])/2 for i in range(len(bins)-1)]
    #    #width of bins:
    #    w = [float(bins[i+1] - bins[i]) for i in range(len(bins)-1)]
        #then make a bar plot:
        
        if linksPokesDistrInOnePlot_b == 1:
            
            ax1_2 = ax1[1]
            
            if pokesDistrLog_b == 1:

                #as above for the links, we want to transform the counts to log10(1+count):
                counts, bins = np.histogram(pokeValuesAll, bins = binsLinks)    
                #bin mid points
                midPts = [float(bins[i] + bins[i+1])/2 for i in range(len(bins)-1)]
                #width of bins:
                w = [float(bins[i+1] - bins[i]) for i in range(len(bins)-1)]
                        
                #then make a bar plot:
                if pokesMinMax_b == 1: #distinguish between the max and min values in plot
                    countsMin, bins = np.histogram(pokeValuesMin, bins = bins)
                    countsMax, bins = np.histogram(pokeValuesMax, bins = bins)
                            
                    ax1_2.bar(midPts, np.log10(1+countsMin), width = w, color = colorMin, alpha = alphaMin)
                    ax1_2.bar(midPts, np.log10(1+countsMax), width = w, color = colorMax, alpha = alphaMax)
    
                else: #don't distinguish min's and max's in plot
                    ax1_2.bar(midPts, np.log10(1+counts), width = w, color = color)
    
                ax1_2.set_ylabel('log(1+count)', fontsize = fontsizeLabel)
    
    
            else: #just make std histogram
            
                if pokesMinMax_b == 1: #distinguish between the max and min values in plot
                    ax1_2.hist(pokeValuesMin, bins = bins, color = colorMin, alpha = alphaMin, fill = True)
                    ax1_2.hist(pokeValuesMax, bins = bins, color = colorMax, alpha = alphaMax, fill = True)
                else: #don't distinguish min's and max's in plot
                    ax1_2.hist(pokeValuesAll, bins = binsPokes, color = color)
                            
                ax1_2.set_ylabel('count', fontsize = fontsizeLabel)
    
            ax1_2.set_xlabel('writhe', fontsize = fontsizeLabel)
            ax1_2.tick_params(labelsize = fontsizeLabel)
            titleDistr = 'Pokes'
            ax1_2.set_title(titleDistr, fontsize = fontsizeTitle)
            
            
        else: #links and pokes distr not shown in one plot 
            if pokesDistrPlotsInSubPlots_b ==1:
                fig2, ax2 = plt.subplots(figsize = (14,8), nrows = 1 , ncols = 3)
                ax2_1 = ax2[1]
                #Re y-axis label: only set for left-most plot (except when using log-count in mid plot )
            else:
                fig2, ax2 = plt.subplots(figsize = (14,8), nrows = 1 , ncols = 1)
                ax2_1 = ax2
                ax2_1.set_ylabel('count', fontsize = fontsizeLabel)
    
        #    plt.bar(midPts, np.log10(1+counts), width = w)
            if pokesMinMax_b == 1: #distinguish between the max and min values in plot
                ax2_1.hist(pokeValuesMin, bins = binsPokes, color = colorMin, alpha = alphaMin, fill = True)
                ax2_1.hist(pokeValuesMax, bins = binsPokes, color = colorMax, alpha = alphaMax, fill = True)    
            else: # don't distinguish
                ax2_1.hist(pokeValuesAll, bins = binsPokes, color = color)
            ax2_1.set_title('All', fontsize = fontsizeSubTitle)
    #        ax2_1.set_ylabel('count', fontsize = fontsizeLabel)
        #    plt.ylabel('log(1+count)')
            ax2_1.set_xlabel('writhe', fontsize = fontsizeLabel)
            ax2_1.tick_params(labelsize = fontsizeLabel)
            titlePokes = titlePokesI
            fig2.suptitle(titlePokes, fontsize = fontsizeTitle)
        
        
            #plot top poke values   
            pokesShowTopNr = min(pokesShowTopNr, L)        
        
            if pokesDistrPlotsInSubPlots_b ==1:
                ax2_2 = ax2[2]
            else:
                fig2, ax2 = plt.subplots(figsize = (14,8), nrows = 1 , ncols = 1)
                ax2_2 = ax2
                
            selectedPokeValues = [pokeValues[i][0] for i in range(pokesShowTopNr) ]
            ax2_2.hist(selectedPokeValues, bins = binsPokes, color = color)
            titlePokes= 'Upper ' + str(len(selectedPokeValues)) + titlePokesII
            ax2_2.set_title(titlePokes, fontsize = fontsizeSubTitle)
            #ax2_2.set_xlabel('writhe', fontsize = fontsizeLabel)
            #set every 2nd xtick:
            j= 0
            xticks = ax2_2.get_xticks()
            xticksNew = []
            while(2*j < len(xticks)):
                xticksNew.append(xticks[2*j])
                j +=1
            ax2_2.set_xticks(xticksNew)
    #        ax2_2.set_ylabel('count', fontsize = fontsizeLabel)
            ax2_2.tick_params(labelsize = fontsizeLabel)
     
    
            #plot bottom poke values   
            if pokesDistrPlotsInSubPlots_b ==1:
                ax2_3 = ax2[0]
            else:
                fig2, ax2 = plt.subplots(figsize = (14,8), nrows = 1 , ncols = 1)
                ax2_3 = ax2
                
            selectedPokeValues = [pokeValues[::-1][i][0] for i in range(pokesShowTopNr) ]
            ax2_3.hist(selectedPokeValues, bins = binsPokes, color = color)
            titlePokes= 'Lower ' + str(len(selectedPokeValues)) + titlePokesII
            ax2_3.set_title(titlePokes, fontsize = fontsizeSubTitle)
            #ax2_3.set_xlabel('writhe', fontsize = fontsizeLabel)
            #set every 2nd xtick:
            j= 0
            xticks = ax2_3.get_xticks()
            xticksNew = []
            while(2*j < len(xticks)):
                xticksNew.append(xticks[2*j])
                j +=1
            ax2_3.set_xticks(xticksNew)
            ax2_3.set_ylabel('count', fontsize = fontsizeLabel)
            ax2_3.tick_params(labelsize = fontsizeLabel)
    

    
    #print out the top 10 potential links and pokes:
    #load segment chains if 3d-plots desired:
    if (plotLinksTop10_b == 1 or plotPokesTop10_b ==1 or plotLinkExs_b == 1 or  plotPokeExs_b == 1 or plotExsInInt_b == 1):
        chains = readResultsCcode_chains(inputFileName = chainsFile)    
    
    m = 10    
    print "Top %d link values:" % len(linkValues[:m])
    print linkValues[:m]  #Obs: sorted above (btw: moved the sorting on 21-Aug2016)
    print "Top %d lowest link values:" % len(linkValues[::-1][:m])
    print linkValues[::-1][:m] 
        
    if plotLinksTop10_b == 1:
        
        if use_pymol_b != 1:
            plotClosedLoopExamples(examples = linkValues[:5], chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern) 
            plotClosedLoopExamples(examples = linkValues[::-1][:5], chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern) 

        elif use_pymol_b == 1:
            pymolPlotClosedExamples(examples = linkValues[:5], chainsDict = chains, stringPattern = stringPattern)
            pymolPlotClosedExamples(examples = linkValues[::-1][:5], chainsDict = chains, stringPattern = stringPattern)


    print "Top %d poke values:" % len(pokeValues[:m])
    print pokeValues[:m] #Obs: sorted above (btw: moved the sorting on 21-Aug2016)
    print "Top %d lowest poke values:" % len(pokeValues[::-1][:m])
    print pokeValues[::-1][:m] #Obs: sorted above (btw: moved the sorting on 21-Aug2016)
    if plotPokesTop10_b ==1: 
        
        if use_pymol_b != 1:
            plotClosedLoopExamples(examples = pokeValues[:5], chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern) 
            plotClosedLoopExamples(examples = pokeValues[::-1][:5], chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern) 

        elif use_pymol_b == 1:
            pymolPlotClosedExamples(examples = pokeValues[:5], chainsDict = chains, stringPattern = stringPattern)
            pymolPlotClosedExamples(examples = pokeValues[::-1][:5], chainsDict = chains, stringPattern = stringPattern)


    #number of links below/above -cutoff/cutoff and plots of these:
    linkValuesExtremePos = []
    linkValuesExtremeNeg = []
    linkValuesInterval = []
    pokeValuesExtremeNeg = []    
    pokeValuesExtremePos = []
    pokeValuesInterval = []

    cntPlus = 0
    cntNeg = 0
    cntInInt = 0
    for ex in linkValues:
        val = ex[0]
        if val > cutOffLinks:
            linkValuesExtremePos.append(ex)
            cntPlus +=1
        if val < -cutOffLinks:
            linkValuesExtremeNeg.append(ex)
            cntNeg +=1
        if (val > intervalLinks[0] and val < intervalLinks[1]):
            linkValuesInterval.append(ex)
            cntInInt +=1
    print "There were %d links having a writhe value below the cutoff: %f" % (cntNeg, -cutOffLinks)
    print linkValuesExtremeNeg
    print "There were %d links having a writhe value above the cutoff: %f" % (cntPlus, cutOffLinks)
    print linkValuesExtremePos
    print "There were %d links having a writhe value in the interval: %s" % (cntInInt, str(intervalLinks))


    if plotLinkExs_b == 1:
        
        if use_pymol_b != 1:
            plotClosedLoopExamples(examples = linkValuesExtremePos, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    
            plotClosedLoopExamples(examples = linkValuesExtremeNeg, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    

        elif use_pymol_b == 1:
            pymolPlotClosedExamples(examples = linkValuesExtremePos, chainsDict = chains, stringPattern = stringPattern)
            pymolPlotClosedExamples(examples = linkValuesExtremeNeg, chainsDict = chains, stringPattern = stringPattern)


    if plotExsInInt_b == 1:
        
        if use_pymol_b != 1:
            plotClosedLoopExamples(examples = linkValuesInterval, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    

        elif use_pymol_b == 1:
            pymolPlotClosedExamples(examples = linkValuesInterval, chainsDict = chains, stringPattern = stringPattern)
        

    cntExPokesPos = 0
    cntExPokesNeg = 0
    cntInInt = 0 #reset
    for ex in pokeValues:
        val = ex[0]
        if val > cutOffPokes:
            pokeValuesExtremePos.append(ex)
            cntExPokesPos +=1
        if val < -cutOffPokes:
            pokeValuesExtremeNeg.append(ex)
            cntExPokesNeg +=1
        if (val > intervalPokes[0] and val < intervalPokes[1]):
            pokeValuesInterval.append(ex)
            cntInInt +=1
    print "There were %d pokes having a writhe value below the cutoff: %f" % (cntExPokesNeg, -cutOffPokes)
    print "There were %d pokes having a writhe value above the cutoff: %f" % (cntExPokesPos, cutOffPokes)
    print "There were %d pokes having a writhe value in the interval: %s" % (cntInInt, str(intervalPokes))
    if plotPokeExs_b == 1:
        
        if use_pymol_b != 1:
            plotClosedLoopExamples(examples = pokeValuesExtremeNeg, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    
            plotClosedLoopExamples(examples = pokeValuesExtremePos, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    

        elif use_pymol_b == 1:
            pymolPlotClosedExamples(examples = pokeValuesExtremeNeg, chainsDict = chains, stringPattern = stringPattern)
            pymolPlotClosedExamples(examples = pokeValuesExtremePos, chainsDict = chains, stringPattern = stringPattern)
            

    if plotExsInInt_b == 1:
        
        if use_pymol_b != 1:        
            plotClosedLoopExamples(examples = pokeValuesInterval, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    

        elif use_pymol_b == 1:
            pymolPlotClosedExamples(examples = pokeValuesInterval, chainsDict = chains, stringPattern = stringPattern)


    plt.show()

    
    if plotDistributions_b == 1 and linksDistrPlotsInSubPlots_b ==2:
        return fig1
    

 

 
         
#version of histoSubChainPairs that distinguishes in the plot the distr's of min/max values: 
def histoSubChainPairs_minMax(subChainPairValues,
                       figIn = '', 
                       axisIn = '',
                       yLabel_b = 1,
                       logCount_b = 0,
                       color = 'grey',
                       colorMin = 'lightgrey',
                       colorMax = 'grey',
                       fontsizeLabel = "large",
                       fontsizeSubTitle = "large",
                       fontsizeTitle = "large",
                       alphaMin = 1.0,
                       alphaMax = 0.8,
                       invName = 'writhe',
                       supTitle_b = 1,
                       titleDistr = 'Distr. of extreme writhe values, unrestricted search',
                       subChainLgth = 30,
                       lowerPercentile = 0.01,
                       upperPercentile = 0.99,
                       bins = 10, 
                       showTopNr = 10,
                       cutOff = 0.9,  
                       chainsFile = '', 
                       addSubplotToFirstPlot_b = 0,
                       addSubPlotNr = 122,
                       distrPlotsInSubPlots_b = 0,
                       few_xticks_b = 0,
                       ticksSize = 'large',
                       plotExs_b = 0, 
                       plotTop10_b = 0, 
                       plotTop4_b = 0,
                       interval = [2,3], 
                       plotExsInInt_b = 0, 
                       elevAzimList =  [[15,-90], [15,0], [90,0]], 
                       color1 = 'red', 
                       markerAtom1 = 'o', 
                       markerLine1 = '-', 
                       color2 = 'blue', 
                       markerAtom2 = 'o', 
                       markerLine2 = '-', 
                       stringPattern = '([\S]+)([^\w]+)([\w]+)\.([\w]+)',
                       use_pymol_b = 0,
                       plotDistributions_b = 1):
    '''Plot histograms of the distributions of the writhe numbers (or: invariant values) 
    for pairs of sub-chains. Makes 3d plots of cases for top4 or top10 writhe value cases
    or cases for which the writhe is outside the interval [-cutOff, cutOff], i.e. 
    of the "exceptional extreme writhe" cases; the relevant pairs of subChains are 
    highlighted in each case. Examples with writhe values inside a set interval 
    can also be chosen (use plotExsInInt_b =1).
    
    Input:
       subChainPairValues: the primary input data. The structure must be as from the
       readResultsCcode_closedLoops with linksAndPokes_b = 0: first read in the data
       
       dict_X, extremeWrithes_X_All, extremeWrithes_X_Min, extremeWrithes_X_Max  = readResultsCcode_closedLoops(.., linksAndPokes_b = 0, ...)

       then convert to the structure expected in this funtion:
       subChainPairValues_X = extremeWrithes_X_All, extremeWrithes_X_Min, extremeWrithes_X_Max
       
       For explicit examples see the Usage section of this module.

       logCount_b (0): if set to 1 the frequency (y-axis) in the distr's will be done by log(count +1)

       lowerPercentile (0.01): see histoClosedLoops_minMax 
       upperPercentile (0.99): see histoClosedLoops_minMax


       figIn ('') and axisIn (''): parameters allowing to input an existing figure and an axis 
       of it (allows to pass an axis for a subplot of the figure, figIn). See also figIn in histoClosedLoops_minMax 
       
 
       addSubplotToFirstPlot_b (0): will add the distr of writhe values as a subplot (as 122 or 
       use addSubPlotNr) to an existing plot. To be used for adding this distr to e.g. a plot of 
       the distr of the writhe values from a restricted search (ie C-outpu for closedLoops and plotted 
       with histoClosedLoops_minMax)
       addSubPlotNr (122): the sub-plot number mentioned used with addSubplotToFirstPlot_b = 1

       bins (10): numbe rof bins used in distribution plot
       showTopNr (10): if this integer is set > 0, the lower and upper tails counting showTopNr examples will be shown in plots flanking the full distribution, if distrPlotsInSubPlots_b = 1, and else as separate plots 
       distrPlotsInSubPlots_b (0): see showTopNr

       few_xticks_b (0): set only three x-ticks: at first bin, at 0 and at last bin
       yLabel_b (1): if set to 1 the y-label is shown, else not.
       ticksSize ('large'): font size of tick labels
              
       titleDistr ('Distr. of extreme writhe values, unrestricted search'): see histoClosedLoops_minMax 
       supTitle_b (1): see histoClosedLoops_minMax 
       subChainLgth (30): will be included in the titles of the distributions (not in all cases)
       color ('grey'): see histoClosedLoops_minMax 
       colorMin ('lightgrey'): see histoClosedLoops_minMax 
       colorMax ('grey'): see histoClosedLoops_minMax 
       fontsizeLabel ("large"): see histoClosedLoops_minMax 
       fontsizeSubTitle ("large"): see histoClosedLoops_minMax 
       fontsizeTitle ("large"): see histoClosedLoops_minMax 
       alphaMin (1.0): see histoClosedLoops_minMax 
       alphaMax (0.8): see histoClosedLoops_minMax 
       invName ('writhe'): to allow indicating the invariant for which the data were obtained
  
       cutOff (0.9): cases having a writhe below/above -cutoff/cutoff will be shown in 3d-plots        
       chainsFile (''): see histoClosedLoops_minMax
       plotExs_b (0): see histoClosedLoops_minMax 
       plotTop10_b (0): like plotLinksTop10_b in see histoClosedLoops_minMax 
       plotTop4_b (0): like plotTop10_b, but only top4 examples are shown
       interval ([2:3]): see intervalLinks in histoClosedLoops_minMax
       plotExsInInt_b (0): see histoClosedLoops_minMax
       elevAzimList ( [[15,-90], [15,0], [90,0]]): see histoClosedLoops_minMax
       color1 ('red'): see histoClosedLoops_minMax
       markerAtom1 ('o'): see histoClosedLoops_minMax
       markerLine1 ('-'): see histoClosedLoops_minMax
       color2 ('blue'): see histoClosedLoops_minMax
       markerAtom2 ('o'): see histoClosedLoops_minMax
       markerLine2 ('-'): see histoClosedLoops_minMax
       stringPattern ('([\S]+)([^\w]+)([\w]+)\.([\w]+)'): see histoClosedLoops_minMax
       use_pymol_b (0): see histoClosedLoops_minMax
       plotDistributions_b (1): see histoClosedLoops_minMax   
    '''

    #read input in proper structure:
    subChainPairValuesAll, subChainPairValuesMin, subChainPairValuesMax = subChainPairValues

    #plot distributions of all values:
    extremeValuesAll = [subChainPairValuesAll[i][0] for i in range(len(subChainPairValuesAll)) ]
    extremeValuesMin = [subChainPairValuesMin[i][0] for i in range(len(subChainPairValuesMin)) ]        
    extremeValuesMax = [subChainPairValuesMax[i][0] for i in range(len(subChainPairValuesMax)) ]
    
    #We want first to find the lower and upper percentiles as desired (approx'ly):
    L = len(extremeValuesAll)
    print "Number of sub-chain pairs: %d" % L

    #Check if the percentiles make sense with the number of examples -- if not: return:
    if (lowerPercentile < 1./L or 1 - upperPercentile < 1./L):
        print "Not all the set percentiles make sense, since there are only %d examples loaded" % L
        return    
    
    #sort the values:
    extremeValuesAll.sort(reverse = False)
    #find indexes "surrounding" the percentiles:
    il_lowerPct = int(np.floor(L*lowerPercentile))
    ir_lowerPct = il_lowerPct +1 # equals int(np.ceil(L*0.01)) unless L*0.01 is integral
    print "idx's left and right of lower percentile %f: %d, %d with values: %f, %f" % (lowerPercentile, il_lowerPct, ir_lowerPct, extremeValuesAll[il_lowerPct], extremeValuesAll[ir_lowerPct] )
    il_upperPct = int(np.floor(L*upperPercentile))
    ir_upperPct = il_upperPct +1 # equals int(np.ceil(L*0.99)) unless L*0.99 is integral
    print "idx's left and right of upper percentile %f: %d, %d with values: %f, %f" % (upperPercentile, il_upperPct, ir_upperPct, extremeValuesAll[il_upperPct], extremeValuesAll[ir_upperPct] )
    #let the desired percentiles be set as the weighted average over the values left and right of the percentile:
    lowerPct = (L*lowerPercentile- il_lowerPct) *extremeValuesAll[ir_lowerPct] + (ir_lowerPct - L*lowerPercentile)*extremeValuesAll[il_lowerPct]
    upperPct = (L*upperPercentile- il_upperPct)*extremeValuesAll[ir_upperPct] + (ir_upperPct - L*upperPercentile)*extremeValuesAll[il_upperPct]
    print "Lower percentile %f pct at: %f; upper percentile %f pct at: %f" % (100*lowerPercentile, lowerPct, 100*upperPercentile, upperPct)
    
    kurAll = stats.kurtosis(extremeValuesAll)
    print "All: Kurtosis is: %f" % kurAll
    
    kurMin = stats.kurtosis(extremeValuesMin)
    print "Min: Kurtosis is: %f" % kurMin
    
    kurMax = stats.kurtosis(extremeValuesMax)
    print "Max: Kurtosis is: %f" % kurMax
    
    #sort before carrying on (though only really needed in the last part):
    subChainPairValuesAll.sort(reverse = True)
    
    if plotDistributions_b == 1:
    
        if addSubplotToFirstPlot_b != 1:
    #        title = 'Distr. of extreme writhe values for pairs of sub-chains of lgth '+ str(subChainLgth) 
            if distrPlotsInSubPlots_b ==1:
                title = 'Sub-chains length '+ str(subChainLgth) #Unrestricted search
                if not(figIn):
                    fig1, ax1 = plt.subplots(figsize = (14,8), nrows = 1 , ncols = 3)   
                    ax_1 = ax1[1]
                else:
                    print("figIn should not be input when having distrPlotsInSubPlots_b =1")
                if supTitle_b == 1:
                    ax_1.set_title(title, fontsize = fontsizeTitle)
            else:
                if figIn:
                    title = invName
                    fig1 = figIn
                    ax_1 = axisIn
                else:
                    fig1, ax1 = plt.subplots(figsize = (14,8), nrows = 1 , ncols = 1)
                    ax_1 = ax1
        else: #if addSubplotToFirstPlot_b == 1
            distrPlotsInSubPlots_b = 2
            fig1 = plt.figure(num = 1) #fetches the first of the list of existing figures
            ax_1 = fig1.add_subplot(addSubPlotNr)
    #        ax_1 = ax1[1]
            title = 'Unrestricted search' #'Sub-chains length '+ str(subChainLgth) #Unrestricted search
            
    #    if distrPlotsInSubPlots_b ==1:
    #        fig.add_subplot(132)
    #        title = 'Distr. of extreme writhe values for pairs of sub-chains of lgth '+ str(subChainLgth) 
    #
    #    if distrPlotsInSubPlots_b ==2:
    #        fig.add_subplot(122)
    #        title = 'Unrestricted search'
            
    #    ax_1 = ax_1.plot(extremeValuesAll)
        if logCount_b != 1:
            
            #we want to plot the distr of the min vals and the distr of the max vals in one plot; 
            #so must use common bins for the two; we use bins derived for all data:
            #Can be done like this:
            counts, bins = np.histogram(extremeValuesAll, bins = bins)
           
            ax_1.hist(extremeValuesMin, bins = bins, color = colorMin, alpha = alphaMin, fill = True, label = invName)
            ax_1.hist(extremeValuesMax, bins = bins, color = colorMax, alpha = alphaMax, fill = True, label = invName)
    
    #        ax_1.legend(fontsize = "xx-small" , markerscale = 0.5)
            ax_1.set_title(title, fontsize = fontsizeTitle)
    
            if yLabel_b == 1:
                ax_1.set_ylabel('count', fontsize = fontsizeLabel)
                    
            if few_xticks_b == 1:
                ax_1.set_xticks((round(bins[0],1), round(bins[25],1), round(0,1), round(bins[75],1), round(bins[len(bins)-1],1)))
                
        elif logCount_b == 1:
            #we want to transform the counts to log10(1+count)
            #Can be done like this:
            counts, bins = np.histogram(extremeValuesAll, bins = bins)
    #        plt.close()
            #bin mid points
            midPts = [float(bins[i] + bins[i+1])/2 for i in range(len(bins)-1)]
            #width of bins:
            w = [float(bins[i+1] - bins[i]) for i in range(len(bins)-1)]
    
            countsMin, bins = np.histogram(extremeValuesMin, bins = bins)
            countsMax, bins = np.histogram(extremeValuesMax, bins = bins)
                            
            ax_1.bar(midPts, np.log10(1+countsMin), width = w, color = colorMin, alpha = alphaMin, label = invName)
            ax_1.bar(midPts, np.log10(1+countsMax), width = w, color = colorMax, alpha = alphaMax, label = invName)
            
    #        ax_1.legend(fontsize = "xx-small" , markerscale = 0.5)
            ax_1.set_title(title, fontsize = fontsizeTitle)
           
            if yLabel_b == 1:
                ax_1.set_ylabel('log(1+count)', fontsize = fontsizeLabel)
    
            if few_xticks_b == 1:
                ax_1.set_xticks((bins[0], 0, bins[len(bins)-1]))
    
            
    #    ax_1.set_title(title, fontsize = "large")
        if not(figIn):
            if supTitle_b == 1:
                plt.suptitle(titleDistr, fontsize = fontsizeTitle)
            ax_1.set_xlabel(invName, fontsize = fontsizeLabel)
        #add a little x-axis to the left and to the right (multiples of 0.25):
        xLimPos = -1.00
        while(xLimPos - bins[len(bins)-1] < 0):
            xLimPos += 0.25
        xLimNeg = 1.00  
        while(bins[0] - xLimNeg < 0):
            xLimNeg -= 0.25
            ax_1.set_xlim(xLimNeg,xLimPos)
        ax_1.tick_params(labelsize = ticksSize)
        if addSubplotToFirstPlot_b != 0:
            plt.figure(num = 1, figureClass = fig1) #will add the plot to the existing (fig1)
    #    plt.tight_layout
        plt.show()
    
    
        #plot top values
        if showTopNr > 0:
            if distrPlotsInSubPlots_b ==1:
                ax_2 = ax1[2]
            else:
                fig2, ax2 = plt.subplots(figsize = (14,8), nrows = 1 , ncols = 1)
                ax_2 = ax2
         
            selectedValuesTop = [subChainPairValuesAll[i][0] for i in range(showTopNr) ]
            ax_2.hist(selectedValuesTop, bins = bins, color = color)
            title = 'Top ' + str(len(selectedValuesTop)) + ' highest ' + invName + ' values for pairs of sub-chains'
            ax_2.set_title(title)
            #plot bottom link values
            if distrPlotsInSubPlots_b ==1:
                ax_3 = ax1[0]
            else:
                fig3, ax3 = plt.subplots(figsize = (14,8), nrows = 1 , ncols = 1)
                ax_3 = ax3
            selectedValuesBottom = [subChainPairValuesAll[::-1][i][0] for i in range(showTopNr) ]
            ax_3.hist(selectedValuesBottom, bins = bins, color = color)
            title = 'Top ' + str(len(selectedValuesBottom)) + ' lowest ' + invName + ' values for pairs of sub-chains'
            ax_3.set_title(title)
        
    
    #print out the top 10 cases:
    #load segment chains if 3d-plots desired:
    if (plotTop4_b == 1 or plotTop10_b == 1 or plotExs_b == 1 or plotExsInInt_b == 1):
        chains = readResultsCcode_chains(inputFileName = chainsFile)    
    
    if (plotTop4_b == 1 or plotTop10_b ==1): 
        if plotTop4_b == 1:
            m = 2
        if plotTop10_b == 1:
            m = 5
        m = 10    
        print "Top %d values:" % len(subChainPairValuesAll[:m])
        print subChainPairValuesAll[:m]   
        print "Top %d lowest values:" % len(subChainPairValuesAll[::-1][:m])
        print subChainPairValuesAll[::-1][:m] 
        
        #plot the examples:        
        if use_pymol_b != 1:
            plotClosedLoopExamples(examples = subChainPairValuesAll[:m], invName = invName, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern) 
            plotClosedLoopExamples(examples = subChainPairValuesAll[::-1][:m], invName = invName, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern) 
        
        elif use_pymol_b == 1:
            pymolPlotClosedExamples(examples = subChainPairValuesAll[:m], invName = invName, chainsDict = chains, stringPattern = stringPattern)
            pymolPlotClosedExamples(examples = subChainPairValuesAll[::-1][:m], invName = invName, chainsDict = chains, stringPattern = stringPattern)

  
    #number of cases below/above -cutoff/cutoff and plots of these:
    extremePos = []
    extremeNeg = []
    valuesInterval = []

    cntPlus = 0
    cntNeg = 0
    cntInInt = 0
    for ex in subChainPairValuesAll:
        val = ex[0]
        if val > cutOff:
            extremePos.append(ex)
            cntPlus +=1
        if val < -cutOff:
            extremeNeg.append(ex)
            cntNeg +=1
        if (val > interval[0] and val < interval[1]):
            valuesInterval.append(ex)
            cntInInt +=1
    print "There were %d cases having a %s value below the cutoff: %f" % (cntNeg, invName, -cutOff)
    print extremeNeg
    print "There were %d cases having a %s value above the cutoff: %f" % (cntPlus, invName, cutOff)
    print extremePos
    print "There were %d cases having a %s value in the interval: %s" % (cntInInt, invName, str(interval))

    if plotExs_b == 1:

        if use_pymol_b != 1:
            plotClosedLoopExamples(examples = extremePos, invName = invName, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    
            plotClosedLoopExamples(examples = extremeNeg, invName = invName, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    

        elif use_pymol_b == 1:
            pymolPlotClosedExamples(examples = extremeNeg, invName = invName, chainsDict = chains, stringPattern = stringPattern)
            pymolPlotClosedExamples(examples = extremePos, invName = invName, chainsDict = chains, stringPattern = stringPattern)

    if plotExsInInt_b == 1:
        
        if use_pymol_b != 1:   
            plotClosedLoopExamples(examples = valuesInterval, invName = invName, chainsDict = chains, elevAzimList = elevAzimList, color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1, color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, stringPattern = stringPattern)    
        
        if use_pymol_b == 1:   
            pymolPlotClosedExamples(examples = valuesInterval, invName = invName, chainsDict = chains, stringPattern = stringPattern)

            
    plt.show()
    


#"Poor man's Pymol": The following plot function generates one or more 3d-pictures of a 
#structure with the ability to color two given segments so as to highlight them. The 
#intended usage is to color a closed loop and a sub chain/closed loop, forming a potential 
#link or poke example:

from mpl_toolkits.mplot3d import Axes3D #needed, see matplotlib.org

def plot_3D_2segmentsHighLight(polyCaChain, 
                               segment1, 
                               segment2, 
                               color1 = 'red', 
                               markerAtom1 = 'o', 
                               markerLine1 = '-', 
                               markerAtomStartPt1 = 'o',
                               startPtSize1 = 75,
                               color2 = 'blue', 
                               markerAtom2 = 'o', 
                               markerLine2 = '-', 
                               markerAtomStartPt2 = 'o',
                               startPtSize2 = 75,
                               elevAzimList = [[0, 36]], 
                               title = '', 
                               outFile = '', 
                               optionOut = 'screen',
                               tubePlot_b = 0,
                               tubeRadius = 0.75,
                               nrOfCircles = 10,
                               nrOfPtsOnCircles = 10):
    '''Creates one ore more 3D plot for the supplied pdb file/protein and colors the two given segments 
    in the set colors. Called by plotClosedLoopExamples and, in turn, by the functions histoSubChainPairs_minMax
    and histoClosedLoops_minMax.
    
    Input:
       polyCaChain: list of [segment start, segment end]; as output by readResultsCcode_chains (see there for more) 
       segment1: [start index, end index] of 1st segment 
       segment2: [start index, end index] of 2nd segment 
       color1 ('red'): high-light color for 1st segment
       markerAtom1 ('o'): marker of C-alphas in 1st segment
       markerLine1 ('-'): marker of C-alphas not in 1st or 2nd segment
       markerAtomStartPt1 ('o'): marker of first C-alpha in 1st segment
       startPtSize1 (75): size of marker of first C-alpha in 1st segment
       color2 ('blue'): as for 1st segment (color1)
       markerAtom2 ('o'): as for 1st segment
       markerLine2 ('-'): as for 1st segment
       markerAtomStartPt2 ('o'): as for 1st segment
       startPtSize2 (75): as for 1st segment
       elevAzimList ([[0, 36]]): list of angles for which to plot; the length of the list should be 1, 2 or 3.
       There will be one subplot for each angle
       title (''): (first part of) title on plot 
       outFile (''): if not blank ('') plot will be written out to this pdf
       optionOut ('screen'): if set to 'pdf' plot will be written out [outFile].pdf
       tubePlot_b (0): for plotting the C-alpha trace (curve) as a tube 
       tubeRadius (0.75): radius of the tube
       nrOfCircles (10): skeleton for tube (nr of circles around each C-alpha-to-C-alpha segment)
       nrOfPtsOnCircles (10): skeleton for tube (approx of circle around the curve)
       '''     
        
#    try:
#        #CaChain, polyCaChain = getPolygonalChain(PDBfilename = pdb_filename, outNumpy_b = 0)
#        CaChain, polyCaChain = readResultsCcode_chains(inputFileName = pdb_filename)
#    except KeyError:
#        print 'Load of this PDB-file: %s failed' % pdb_filename
#        return    
    
    fig = plt.figure()
    L = len(elevAzimList)
    cnt = 1
    i_e = 0
    for i_e in range(L): #elevAzim in elevAzimList:
        elevAzim = elevAzimList[i_e]
#        print "Subplot nr:%d " % 100 + L*10  + cnt
        ax = fig.add_subplot(100 + L*10  + cnt ,projection ='3d') #adds 3rd axis
    
        seg0 = []
        seg1 = []
        seg2 = []
        startPtSeg1 = []
        startPtSeg2 = []
        for i in range(len(polyCaChain)):
            pt0 = polyCaChain[i][0]
            x1 = [pt0[0], pt0[1],pt0[2]]
            pt1 = polyCaChain[i][1]        
            x2 = [pt1[0], pt1[1],pt1[2]]
            seg0.append(x1)
            if (segment1[0]<= i and i <= segment1[1]): #use color1 if the C-alpha (residue) is in segment1
    #            print "at i:%d color is : %s" % (i, color1)
                seg1.append(x1)
                #we have appended the starting pt of each segment; for the last segment append alos the end point:
                if i == segment1[1]:
                    seg1.append(x2)
    #            ax.scatter(x1, 'o', c=color1)
                #we want to indicate the starting point of the segment, so store it:
                if i == segment1[0]:
                    startPtSeg1 = x1
            #Obs: we use an "if" next rather than an "elif": only diff is that it can happen that 
            #segment1[1] = segment2[0] in which case the elif will imply that there'll be no
            #startPtSeg2! This does not happen when using an if instead:
            if (segment2[0]<= i and i <= segment2[1]): #use color2 if the C-alpha (residue) is in segment2
    #            ax.scatter(x1, 'o', c=color2)
    #            print "at i:%d color is : %s" % (i,color2)
                seg2.append(x1)
                #we have appended the starting pt of each segment; for the last segment append alos the end point:
                if i == segment2[1]:
                    seg2.append(x2)
                #we want to indicate the starting point of the segment, so store it:
                if i == segment2[0]:
                    startPtSeg2 = x1
        segs = [seg0,seg1,seg2]
        for i in range(3):
            thisPart = np.array(segs[i])   
            x = thisPart[:,0]
            y = thisPart[:,1]
            z = thisPart[:,2]
            #first color all black and then overwrite in segment1 & 2:
            if i == 0:
                col = "black"
                ax.plot(x,y,z, '-', c=col, linewidth = 2)    
    #            ax.scatter(x,y,z, ".", c = col)  
            elif i ==1:
                mrkLine = markerLine1
                mrkAtom = markerAtom1
                col = color1
                ax.scatter(x,y,z, mrkAtom, c = col)
                #indicate the start point:
                x0 = startPtSeg1[0]
                x1 = startPtSeg1[1]
                x2 = startPtSeg1[2]
#                print "start point 1: %f, %f, %f" % (x0,x1,x2)
                ax.scatter(x0, x1, x2, markerAtomStartPt1, c = col, s = startPtSize1) 
                #plot the set of line segments, or, if desired, "tubing them" 
                if tubePlot_b != 1:            
                    ax.plot(x,y,z, mrkLine, c=col, linewidth = 5, alpha = 0.5)    
                else: #generate a tube around the segments
                    for i in range(len(seg1)-1):
                        #generate a series of nrOfCircles circles placed around each segment, in planes perpendicular to the direction of the segment
                        #compute angles for tilting the circles to be placed around the line segments:
                        v = np.array(seg1[i+1]) - np.array(seg1[i]) #vector along line segment
                        theta = np.arctan2(v[1], v[0])
                        phi = np.arctan2(v[2], np.sqrt(v[0]*v[0] + v[1]*v[1]) )
#                        X = np.zeros(shape = (nrOfCircles,nrOfPtsOnCircles +1))
#                        Y = np.zeros(shape = (nrOfCircles,nrOfPtsOnCircles +1))
#                        Z = np.zeros(shape = (nrOfCircles,nrOfPtsOnCircles +1))

                        for j in range(nrOfCircles):
                            c = float(j)/nrOfCircles*np.array(seg1[i+1]) + (1- float(j)/nrOfCircles)*np.array(seg1[i])
                            #pts = tiltedCircleCosSin(np.array(c), 1, cosTheta, sinTheta, cosPhi, sinPhi, 10)
                            pts = tiltedCircle(np.array(c), tubeRadius, theta - np.pi*0.5, phi - np.pi*0.5 , nrOfPtsOnCircles)
                            x_pts = pts.T[0]
                            y_pts = pts.T[1]
                            z_pts = pts.T[2]
                            #ax.scatter(x_pts, y_pts, z_pts, "*", c = col)
                            ax.plot(x_pts, y_pts, z_pts, "-", c = col, alpha = 0.5)
                            #keep record of the first and last circle for next step
                            if j == 0:
                                x_pts_start = pts.T[0]
                                y_pts_start = pts.T[1]
                                z_pts_start = pts.T[2]
                            if j == nrOfCircles -1:
                                x_pts_end = pts.T[0]
                                y_pts_end = pts.T[1]
                                z_pts_end = pts.T[2]
#                            X[j] = x_pts
#                            Y[j] = y_pts
#                            Z[j] = z_pts
#                        surf = ax.plot_surface(X.T, Y.T,Z.T,  color = col, facecolors = col, alpha = 0.5)
                        #generate a series of straight line segments connecting the circles:
                        for j in range(nrOfPtsOnCircles-1):
                            x = [x_pts_start[j], x_pts_end[j]]
                            y = [y_pts_start[j], y_pts_end[j]]
                            z = [z_pts_start[j], z_pts_end[j]]
                            #ax.plot(x,y,z, mrkLine, c=col, linewidth = 2, alpha = 0.5)  
                            ax.plot_trisurf([x_pts_start[j], x_pts_end[j], x_pts_start[j+1], x_pts_end[j+1]], [y_pts_start[j], y_pts_end[j], y_pts_start[j+1], y_pts_end[j+1]], [z_pts_start[j], z_pts_end[j], z_pts_start[j+1], z_pts_end[j+1]] , color = 'green', alpha = 0.5)
                            #surf = ax.plot_surface([x_pts_start[j], x_pts_end[j], x_pts_start[j+1], x_pts_end[j+1]], [y_pts_start[j], y_pts_end[j], y_pts_start[j+1], y_pts_end[j+1]], [z_pts_start[j], z_pts_end[j], z_pts_start[j+1], z_pts_end[j+1]] , color = col, facecolors = col, alpha = 0.5)

                
            elif i == 2:
                mrkLine = markerLine2
                mrkAtom = markerAtom2
                col = color2
                ax.scatter(x,y,z, mrkAtom, c = col)            
                #indicate the start point:
                x0 = startPtSeg2[0]
                x1 = startPtSeg2[1]
                x2 = startPtSeg2[2]
#                print "start point 2: %f, %f, %f" % (x0,x1,x2)
                ax.scatter(x0, x1, x2, markerAtomStartPt2, c = col, s = startPtSize2) 
                #plot the set of line segments, or, if desired, "tubing them" 
                if tubePlot_b != 1:            
                    ax.plot(x,y,z, mrkLine, c=col, linewidth = 5, alpha = 0.5)
                else: #generate a tube around the segments
                    for i in range(len(seg2)-1):
                        #generate a series of nrOfCircles circles placed around each segment, in planes perpendicular to the direction of the segment
                        #compute angles for tilting the circles to be placed around the line segments:
                        v = np.array(seg2[i+1]) - np.array(seg2[i]) #vector along line segment
                        theta = np.arctan2(v[1], v[0])
                        phi = np.arctan2(v[2], np.sqrt(v[0]*v[0] + v[1]*v[1]) )
                        for j in range(nrOfCircles):
                            c = float(j)/nrOfCircles*np.array(seg2[i+1]) + (1- float(j)/nrOfCircles)*np.array(seg2[i])
                            #pts = tiltedCircleCosSin(np.array(c), 1, cosTheta, sinTheta, cosPhi, sinPhi, 10)
                            pts = tiltedCircle(np.array(c), tubeRadius, theta - np.pi*0.5, phi - np.pi*0.5 , nrOfPtsOnCircles)
                            x_pts = pts.T[0]
                            y_pts = pts.T[1]
                            z_pts = pts.T[2]
                            #ax.scatter(x_pts, y_pts, z_pts, "*", c = col)
                            ax.plot(x_pts, y_pts, z_pts, "-", c = col, alpha = 0.3)
                            #keep record of the first and last circle for next step
                            if j == 0:
                                x_pts_start = pts.T[0]
                                y_pts_start = pts.T[1]
                                z_pts_start = pts.T[2]
                            if j == nrOfCircles -1:
                                x_pts_end = pts.T[0]
                                y_pts_end = pts.T[1]
                                z_pts_end = pts.T[2]       
                        #generate a series of straight line segments connecting the circles:
                        for j in range(nrOfPtsOnCircles):
                            x = [x_pts_start[j], x_pts_end[j]]
                            y = [y_pts_start[j], y_pts_end[j]]
                            z = [z_pts_start[j], z_pts_end[j]]
                            #ax.plot(x,y,z, mrkLine, c=col, linewidth = 2, alpha = 0.3)  
                            ax.plot_trisurf([x_pts_start[j], x_pts_end[j], x_pts_start[j+1], x_pts_end[j+1]], [y_pts_start[j], y_pts_end[j], y_pts_start[j+1], y_pts_end[j+1]], [z_pts_start[j], z_pts_end[j], z_pts_start[j+1], z_pts_end[j+1]] , color = col, alpha = 0.5)

                
#        print elevAzim
        elev = elevAzim[0]
        azim = elevAzim[1]          
        ax.view_init(elev=elev,azim =azim)
            
        cnt +=1
        
#    if not(title):
#        #find the PDB name (avoiding the file path)
#        pattern = re.compile('([\S]+)([^\w]+)([\w]+).([\S]+)')
#        m = pattern.match(pdb_filename)
#        title = m.group(3)
    plt.suptitle(title + ', '+ str(segment1) + ', '+ str(segment2), fontsize = "x-large")
    
    
    if optionOut == 'pdf':
        plt.savefig(outFile)
        
    return ax
    


def plotClosedLoopExamples(examples, 
                           invName = 'writhe',
                           chainsDict = {}, 
                           elevAzimList = [[0,36]], 
                           color1 = 'black', 
                           color2 = 'grey',
                           markerAtom1 = 'o', 
                           markerLine1 = '-', 
                           markerAtom2 = 'o', 
                           markerLine2 = '-', 
                           stringPattern = '([\S]+)([^\w]+)([\w]+)\.([\w]+)'):
    '''Plot (3d) a set of closed loop examples such as those returned when loading the C-results
    using readResultsCcode_closedLoops (e.g. look at a subset such as linkValues[:10]); calls 
    the fct plot_3D_2segmentsHighLight to plot each example. In each example the segments are
    high-lighted by distinct colors/markers.
    
    The function is itself called by the functions by the functions histoClosedLoops_minMax and 
    histoSubChainPairs_minMax.    
    
    Input:
    
       examples: as output from readResultsCcode_closedLoops (or part of it); see histoClosedLoops_minMax and histoSubChainPairs_minMax.
       chainsDict: as output from readResultsCcode_chains; see histoClosedLoops_minMax and histoSubChainPairs_minMax.
    
       invName ('writhe'): see histoSubChainPairs_minMax
       elevAzimList ([[0, 36]]): see plot_3D_2segmentsHighLight
       color1 ('red'): see plot_3D_2segmentsHighLight
       color2 ('blue'): see plot_3D_2segmentsHighLight
       markerAtom1 ('o'): see plot_3D_2segmentsHighLight    
       markerLine1 ('-'): see plot_3D_2segmentsHighLight    
       markerAtom2 ('o'): see plot_3D_2segmentsHighLight    
       markerLine2 ('-'): see plot_3D_2segmentsHighLight    
       stringPattern ('([\S]+)([^\w]+)([\w]+)\.([\w]+)'): see histoClosedLoops_minMax
       '''
    
    for ex in examples:
        val = ex[0]
        pdb_filename = ex[1]
        chainId = ex[2]
#        print pdb_filename
        segment1 = ex[3]
        segment2 = ex[4]
        #gen plot title
        #first find the PDB name (avoiding the file path)
        pattern = re.compile(stringPattern)
#        print pdb_filename
        m = pattern.match(pdb_filename)
        title = m.group(3)
        #now add the writhe value too:
        title = title + ' chain: ' + chainId + ', ' + invName + ': ' + str(val)
        #fetch the segments chain:
        try: 
            polyCaChain = chainsDict[pdb_filename][chainId][1]
        except KeyError:
            print 'Load of recorded data for this PDB-file: %s chain: %s failed' % (pdb_filename, chainId)
            continue        
#        print "Now at structure: %s chain: %s" %  (pdb_filename, chainId)
        #call the plot fct:
        ax = plot_3D_2segmentsHighLight(polyCaChain, segment1, segment2, 
                                   color1 = color1, markerAtom1 = markerAtom1, markerLine1 = markerLine1,
                                   color2 = color2, markerAtom2 = markerAtom2, markerLine2 = markerLine2, 
                                   elevAzimList = elevAzimList, title = title, outFile = '', optionOut = 'screen')

#        return ax


#For generating small Pymol scripts for a set of examples:
def pymolPlotClosedExamples(examples,
                           invName = 'writhe',
                           chainsDict = {},
                           angles = [0,90,180],
                           bg_color = 'white',
                           color = 'lightorange',
                           color1 = 'red', 
                           color2 = 'blue', 
                           pdbFileExtension = '',
                           stringPattern = '([\S]+)([^\w]+)([\w]+)\.([\w]+)'):
    '''Function similar to plotClosedExamples, but for use in Pymol (generates the plots in Pymol)
    In each example the two sub strings (segments) are highlighted in the set colors (color1, color2). The
    function plots all examples in one Pymol session, placing each plot in a grid slot (Pymol grid_mode is 
    called). This mutli plot can then be handled in Pymol (e.g. switching only one plot on at a time etc).
    
    Input:
    
       examples: see plotClosedExamples
       invName ('writhe'): see histoSubChainPairs_minMax
       chainsDict ({}): see histoClosedLoops_minMax and histoSubChainPairs_minMax
       angles ([0,90,180]): angles at which each example is plotted (the number of plots follows the number of angles)
       bg_color ('white'): back ground colour in Pymol
       color ('lightorange'): color of backbone (C-alpha trace)
       color1 ('red'): color of 1st segment
       color2 ('blue'): color of 2nd segment
       pdbFileExtension (''): as used (e.g. '.txt', '.pdb')   
       stringPattern ('([\S]+)([^\w]+)([\w]+)\.([\w]+)': see histoClosedLoops_minMax
    
    '''

    cmd.bg_color(bg_color)
    cmd.set('pdb_ignore_conect', 'on'); #this will ignore "CONECT" records in the pdb files (e.g. one only gets fragments of 2er7H if not)
#    cmd.set('connect_mode', '2');
 
    structureShown = [] #diff examples in the same PDB may occur, so we keep track of which and attach an index in the objName

    cntExs = 0
    cntFig = 0 #to keep track also of the grid slot nr in which to place the objects
    
    cmd.set('grid_mode')
    
    #to save a little space in th annotation of the plots: 
    if invName == 'writhe':
        invName = 'w'

    for ex in examples:

        val = round(ex[0],3)
        pdb_filename = ex[1]
        chainId = ex[2]
        print "Showing example in: %s chain: %s " % (pdb_filename, chainId)
        segment1 = ex[3]
        segment2 = ex[4]
        print segment1
        print segment2
        
        #we need the residue numbers corr to the segments; these are stored as part of the chain:
        #fetch the segments chain:
        try: 
            cAlphaCoordsAndResNr = chainsDict[pdb_filename][chainId][0]
        except KeyError:
            print 'Load of this PDB-file: %s chain: %s failed' % (pdb_filename, chainId)
            continue 

        #If succesful, the residue numbers now are:
        segment1resNr1 = cAlphaCoordsAndResNr[segment1[0]][1] #res nr at beginning of segment1  
        segment1resNr2 = cAlphaCoordsAndResNr[segment1[1]][1] #res nr at end of segment1  
        segment2resNr1 = cAlphaCoordsAndResNr[segment2[0]][1] #res nr at beginning of segment2 
        segment2resNr2 = cAlphaCoordsAndResNr[segment2[1]][1] #res nr at end of segment2
        #For convenience let:
        segment1resNr = [segment1resNr1, segment1resNr2]
        segment2resNr = [segment2resNr1, segment2resNr2]
        #first find the PDB name (avoiding the file path)
        pattern = re.compile(stringPattern)
        print pdb_filename
        m = pattern.match(pdb_filename)
        pdbId = m.group(3)
        
        print "pdb id: ", pdbId

        pdbAndChainId = pdbId + r'/' + chainId
        structureShown.append(pdbAndChainId)
        
        #loop over the angles; for each, import the structure to Pymol, and show it at the angle (turn around y-axis)
        for i in range(len(angles)):
            
            cntFig += 1 
             
            objIdx = structureShown.count(pdbAndChainId)
            objNameTot = pdbId + '_' + str(objIdx) + '_' + str(i) # + chainId
            print "objNameTot (all chains): ", objNameTot
            cmd.load(pdb_filename + pdbFileExtension, objNameTot)
            
            cmd.set('grid_slot', cntFig , objNameTot)

            cmd.hide('everything',objNameTot)
            
            #Select the given chain (if == '>' the chain id in pdb is '')
            if chainId != '>':
                selectChainString = objNameTot + ' and chain ' + chainId
                objName = pdbId + '_' + chainId + '_' + str(objIdx) + '_' + str(i) 
                cmd.select(objName, selectChainString)
            else:
                objName = objNameTot
            

            cmd.rotate(axis= 'y', angle = angles[i], selection = objName)

            cmd.orient(objName)
            cmd.zoom(objName)            
            
            cmd.bg_color(bg_color)
            cmd.show_as('cartoon', objName)
            cmd.cartoon('tube', objName)
            cmd.color('lightorange',objName)
        
           
#            cmd.do('com  position = cmd.centerofmass()')
#            cmd.do('center com')
#            
            if chainId != '>':               
                selectStringResi1 = objNameTot + ' and chain ' + chainId + ' and resi ' + str(segment1resNr[0]) + '-' + str(segment1resNr[1])
            else:
                selectStringResi1 = objNameTot + ' and resi ' + str(segment1resNr[0]) + '-' + str(segment1resNr[1])
                
#            print selectStringResi1
            resi1Name = "%s%s%s"%(objName,"sele1", segment1resNr)
            cmd.select(resi1Name, selectStringResi1)
            cmd.do("color red, " + selectStringResi1)            
            
            if chainId != '>': 
                selectStringResi2 = objNameTot + ' and chain ' + chainId + ' and resi ' + str(segment2resNr[0]) + '-' + str(segment2resNr[1])                    
            else:
                selectStringResi2 = objNameTot + ' and resi ' + str(segment2resNr[0]) + '-' + str(segment2resNr[1])
#            print selectStringResi2
            resi2Name = "%s%s%s"%(objName,"sele2", segment2resNr)
            cmd.select(resi2Name, selectStringResi2)
            cmd.do("color blue, " + selectStringResi2)   

            #combined selection of sele1 and sele2 for labeling:
            selectStringResi12 = objName + ' and resi ' + str(segment1resNr[0]) + '-' + str(segment1resNr[1]) + ' resi ' + str(segment2resNr[0]) + '-' + str(segment2resNr[1])
#            print selectStringResi12
            resi12Name = "%s%s"%(objName,"sele12")
            cmd.select(resi12Name, selectStringResi12)
            
            
            #add a label by adding a pseudoatom and labeling that:
            if i == 1:
                r = rgyrate(objName)
                psaName = objName + 'forLabel'
                label = pdbAndChainId + '; (' + str(segment1resNr[0]) + '-' + str(segment1resNr[1]) + '); (' + str(segment2resNr[0]) + '-' + str(segment2resNr[1]) + '); ' + invName + ':' + str(val)
#                print label
                cmd.pseudoatom(psaName, selection = resi12Name, label = label)
#                    cmd.pseudoatom(psaName, pos = [0,0,0], label = label)
                cmd.set('grid_slot', cntFig, psaName)
                cmd.translate(vector = [0,-2.5*r,0], selection = psaName)
                cmd.set('label_size', 17)
                cmd.set('label_color','black')
                

        cntExs += 1                            

            
            
#R of gyration: From pymol wiki, due to T.Wassenaar
#from pymol import cmd
from itertools import izip
import math

def rgyrate(selection='(all)', quiet=1):
    '''
DESCRIPTION

    Radius of gyration

USAGE

    rgyrate [ selection ]
    '''
    quiet = int(quiet)
    model = cmd.get_model(selection).atom
    x = [i.coord for i in model]
    #mass = [i.get_mass() for i in model]
    mass = []
    for i in model:
        try:
            mass.append(i.get_mass())
        except KeyError:
            continue
    xm = [(m*i,m*j,m*k) for (i,j,k),m in izip(x,mass)]
    tmass = sum(mass)
    rr = sum(mi*i+mj*j+mk*k for (i,j,k),(mi,mj,mk) in izip(x,xm))
    mm = sum((sum(i)/tmass)**2 for i in izip(*xm))
    rg = math.sqrt(rr/tmass - mm)
    if not quiet:
        print "Radius of gyration: %.2f" % (rg)
    return rg



###############################################################
##    For enabling execution from Pymol 
###############################################################

cmd.extend('readResultsCcode_closedLoops', readResultsCcode_closedLoops)
cmd.extend('histoClosedLoops_minMax',histoClosedLoops_minMax)    
cmd.extend('histoSubChainPairs_minMax',histoSubChainPairs_minMax)  
cmd.extend("rgyrate", rgyrate)  


###############################################################
## For performance plotting
###############################################################

'''
#run:
import gi_Anomalies as git

root = r'C:\Users\Christian\Bioinformatics\papers\geometric_anomalies_in_folds\c_code\results_C_5th\double_precision'

db = 'top100'
fitIn terval = [0,600]

#Compare time consumption at diff orders: 
#aggr time
title = 'Avg time consumption by length at varying order (' + db + ')'
git.plotCTimeByOrders(pathCresultFiles = root, orderList = [1,2,3], PDBlist = '', fileId =  r'_minmax_computeGI_' + db + '_rep.txt', timeType = 'aggrTime', title = title, fitInterval = fitInterval)
#cpu time (used in Suppl)
title = 'Avg time consumption by length at varying order (' + db + ')'
git.plotCTimeByOrders(pathCresultFiles = root, orderList = [1,2,3], PDBlist = '', fileId =  r'_minmax_computeGI_' + db + '_rep.txt', timeType = 'cpuTime', title = title, fitInterval = fitInterval)


#Compare time comsumption by methods (ie w or wo search invoked)
order= 2
fitOrder = 2
pathCresultFilesList0 = root + '\\Ivalues_order_' + str(order) + '_minmax_computeGI_' + db + '_rep.txt'
pathCresultFilesList1 = root + '\\Ivalues_order_' + str(order) + '_minmax_computeGI_' + db + '_rep_wRestrSearch.txt'
pathCresultFilesList2 = root + '\\Ivalues_order_' + str(order) + '_minmax_computeGI_' + db + '_rep_wUnrestrSearch.txt'
pathCresultFilesList = [pathCresultFilesList0, pathCresultFilesList1, pathCresultFilesList2]
#aggr time
title = 'Avg time consumption by length for different methods (' + db + ')'
git.plotCTimeByMethod(pathCresultFilesList, methodList = ['base','Restr', 'Unrestr'], timeType = 'aggrTime', title = title, fitOrder = fitOrder, fitInterval = fitInterval)
#cpu time (used in Suppl)
title = 'Avg time consumption by length for different methods (' + db + ')'
git.plotCTimeByMethod(pathCresultFilesList, methodList = ['base','Restr', 'Unrestr'], timeType = 'cpuTime', title = title, fitOrder = fitOrder, fitInterval = fitInterval)

'''

PDBtop100Folder = "C://Users//Christian//BioInformatics//masters_study_pgm//projects//knots//code//top100H//"


def readResultsCcode(inputFileName, all_b = 0, pert_b = 0, pertTime_b = 0, stringPattern = ''):
    '''Read in results obtained by running GIsquared.
    Output: dictionary mapping each pdb-file (name given as path to file), chain id,
    (pert no = 0 if pert_b = 1) to dictionary containing the results: this dictionary 
    maps each measure name (e.g. I12) to its value, including the structure's lengt
    (str length) as a measure (ie "str length" is a key in the dict)
    Input:
    all_b: read in from and "all values file" (whole simplex results) or only
    from "final corner". (all_b = 1 is pt not covered)
    pert_b: read in from file with non-perturbation results (0) or from a 
    file containing perturbation results. (in non-pert files the perturbation
    number will be 1, viz the unperterubed case).
    stringPattern: set = '([\S]+)[\\\]([\S]+) to get the file name
    (as in path//to//results//fileName) possibly wo extension as key in 
    returned dict.'''

    readOrder = ["PDB_file", 
           "chain id",
           "chain nr",
		    "str length",
			"order",
           "perturbation number",
			"cpuTime",
           "aggrTime",
			#/*order 1*/
			"I12", 
			"Ia12",
			#/*order 2:*/
			"I1234", 
			"I1324", 
			"I1423",
			#/*abs value versions:*/
			#/*12*/
			"Ia1234",
			"I12a34",
			"Ia12a34",
			#/*13*/
			"Ia1324",
			"I13a24",
			"Ia13a24",
			#/*14*/
			"Ia1423",
			"I14a23",
			"Ia14a23",
			#/*order 3*/
			"I123456",
			"I123546",
			"I123645",
			#/*13*/
			"I132456",
			"I132546",
			"I132645",
			#/*14*/
			"I142356",
			"I142536",
			"I142635",
			#/*15*/
			"I152346",
			"I152436",
			"I152634",
			#/*16*/
			"I162345",
			"I162435",
			"I162534"]

    outDict = {}
    rowCnt = 0
    pattern = re.compile(stringPattern)
    if (all_b != 1 and pert_b !=1) :
        with open(inputFileName, 'r') as CresultsTxt:
            Cresults = csv.reader(CresultsTxt, delimiter = ';')
            for row in Cresults:
                if rowCnt == 0:
                    rowCnt += 1
                    continue
                strName = row[0]
                if stringPattern != '':
                    m = pattern.match(strName)
                    strName = m.group(2)
#                    print row[0]
#                    print strName
                    
                if not(outDict.has_key(strName)):
                    outDict[strName] = {}
                if not(outDict[strName].has_key(row[1])): #row[1] is the chain id
                    outDict[strName][row[1]] = {}
                    for i in range(len(readOrder))[2:]:
                        if i!=5: #skip the pertubation number
                            #print readOrder[i]
                            name = readOrder[i]
                            outDict[strName][row[1]][name] = row[i]
                        i +=1
                rowCnt += 1
    if (all_b != 1 and pert_b == 1):
        with open(inputFileName, 'r') as CresultsTxt:
            Cresults = csv.reader(CresultsTxt, delimiter = ';')
            rowCnt = 0
            for row in Cresults: 
#                print row
                if rowCnt >0:#skip first "header" row
                    strName = row[0]
                    if stringPattern != '':
                        m = pattern.match(strName)
                        strName = m.group(2)
                        print row[0]
                        print strName
                    if not(outDict.has_key(strName)):
                        outDict[strName] = {}
                    if not(outDict[strName].has_key(row[1])): #row[1] is the chain id
                        outDict[strName][row[1]] = {}
                        if not(outDict[strName].has_key(row[5])): #row[5] is the perturbation number
                            outDict[strName][row[1]][row[5]] = {}
                            if pertTime_b ==0:
                                #read length of structure in separately:
                                outDict[strName][row[1]][row[5]]["str length"] = int(row[3])
                                for i in range(len(readOrder))[8:]: #skip info in the first col's
                                    #print "row[%d]:%s" % (i, str(row[i]))
                                    name = readOrder[i]
                                    outDict[strName][row[1]][row[5]][name] = row[i]
                                    i +=1
                            elif pertTime_b ==1:
                                for i in range(len(readOrder))[:6]: #for pert time there's only info in first 6 col's
                                    #print "row[%d]:%s" % (i, str(row[i]))
                                    name = readOrder[i]
#                                    print name
                                    outDict[strName][row[1]][row[5]][name] = row[i]
                                    i +=1
                    else: #to cover the case of repeated runs of the code
                        if pertTime_b ==1:
                            outDict[row[0]][row[3]]['cpuTime'] = float(outDict[row[0]][row[3]]['cpuTime'])+ float(row[4])
                            outDict[row[0]][row[3]]['aggrTime'] = float(outDict[row[0]][row[3]]['aggrTime']) + float(row[5])
                        
                rowCnt += 1

    return outDict
    
    
def readSearchResultsCcode(inputFileName,  stringPattern = ''):
    '''Read in results obtained by running the C-version search code (for restriced 
    or unrestricted searching).
    Output: dictionary mapping each pdb-file (name given as path to file), chain id,
    search object ("subchainPair", "poke" or "link") and index keys for the two subchains 
    in question to the corresponding mutual writhe value. The index keys is a list with structure
    [subchain1 start-index, subchain1 end-index, subchain1 start-index, subchain1 end-index]
   
    Input:
    stringPattern: set = '([\S]+)[\\\]([\S]+) to get the file name
    (as in path//to//results//fileName) possibly wo extension as key in 
    returned dict.'''

    readOrder = ["PDB_file", 
           "chain id",
           "searchObjectType",
           "subchain1 start-index", 
           "subchain1 end-index", 
           "subchain1 start-index",
           "subchain1 end-index", 
           "mutual writhe value"
		    ]

    outDict = {}
    rowCnt = 0
    pattern = re.compile(stringPattern)
    with open(inputFileName, 'r') as CresultsTxt:
        Cresults = csv.reader(CresultsTxt, delimiter = ';')
        for row in Cresults:
            strName = row[0]
            if stringPattern != '':
                m = pattern.match(strName)
                strName = m.group(2)
#                    print row[0]
#                    print strName
                
            if not(outDict.has_key(strName)):
                outDict[strName] = {}
            if not(outDict[strName].has_key(row[1])): #row[1] is the chain id
                outDict[strName][row[1]] = {}
            if not(outDict[strName][row[1]].has_key(row[2])): #row[2] is the search object type
                outDict[strName][row[1]][row[2]] = {}
            #Generate index key list:
            keyList = []
            for i in range(len(readOrder))[3:7]:
                #name = readOrder[i]
                keyList.append(row[i])
                i +=1
            outDict[strName][row[1]][row[2]][str(keyList)] = float(row[7]) #mutual writhe value
            rowCnt += 1

    return outDict


def plotCTimeByOrders(pathCresultFiles, 
                      orderList, 
                      PDBlist, 
                      fileId =  r'_minmax_computeGI_top100_rep.txt', 
                      timeType = 'cpuTime', 
                      title = "Time consumption (C) by length",
                      fitOrder = 3,
                      fitInterval = [0,600]):
    '''Plots the time (as defined by timeType) for each order in the 
    orderList of the input results from using the C code (sitting in 
    pathCresultFiles). The C-results must be for the PDB-files in the PDBlist.'''
    

    color = ['blue', 'red', 'green']
    
    plt.figure()
    xp = np.linspace(fitInterval[0], fitInterval[1], 100)
    
    for order in orderList:
        #load the C-results:
        CresFile = pathCresultFiles + r'\Ivalues_order_' + str(order) + fileId
#        print CresFile
        CresultsDict = readResultsCcode(inputFileName = CresFile, all_b = 0)
        
        Clist = []
        lengthListC = []
    
        for f in CresultsDict.keys():
#            print f
#            print CresultsDict[f].keys()
            L = CresultsDict[f]["str length"]
#            print L
            try:
                timeC = float(CresultsDict[f][timeType])
                lengthListC.append(int(L))
                Clist.append(timeC)
            except KeyError:
                print "This file: %s was not present in C-results for order %d" % (f,order)
        #make the plot
#        print lengthListC
#        print Clist
        pts = zip(lengthListC, Clist)
        pts.sort()
#        print pts
#        plt.scatter(lengthListC,Clist, color = color[order-1],label = str(order))
        
        polyfitTwo = np.polyfit(np.array(lengthListC), Clist, deg = 2, cov = False)
        print "polyfitTwo", polyfitTwo
        pTwo = np.poly1d(polyfitTwo)
        polyfitFitOrder= np.polyfit(np.array(lengthListC), Clist, deg = fitOrder, cov = False)
        print "polyfitFitOrder", polyfitFitOrder
        pfitOrder = np.poly1d(polyfitFitOrder)
        plt.plot(lengthListC, Clist, '.', label = 'GI order '+ str(order), color = color[order-1], alpha = 0.75)
        plt.plot(xp, pTwo(xp), '-', label = 'polyn. order = 2', color = color[order-1], alpha = 0.75)
        plt.plot(xp, pfitOrder(xp),'--', label = 'polyn. order = ' + str(fitOrder), color = color[order-1], alpha = 0.75)
        plt.show()
    
    # the plot
    plt.xlabel('length (nr of residues)', fontsize = 'small')
    plt.ylabel('time (s)', fontsize = 'small')
    plt.legend(loc = "upper left", fontsize = 'small')
    plt.title(title, fontsize = 'medium')
    
    
def plotCTimeByMethod(pathCresultFilesList, 
                      fig = '', 
                      fileId1 =  r'_incl_abs_', 
                      fileId2 =  r'lgth10_100_perts_rnd_top100.txt',  
                      methodList = [''], 
                      order = 2, 
                      timeType = 'cpuTime',
                      title = "Time consumption (C) by method",
                      subPlotNr = 111, 
                      fitOrder = 2, 
                      fitInterval = [0,600]):
    '''Plots the time (as defined by timeType) for each file in the pathCresultFilesList
    storing the input results from using the C code. The methodList must corrspond to the 
    methods (or: versions) used; each method is given by a pair (name, pert_b) where name is
    the name of the method (e.g 'global_gpu') and pert_b is a boolean indicating whether the
    method was used with perturbations (1) or not (0). All C-results must be for the PDB-files 
    in the PDBlist.'''
    if not(fig): #get new figure if none was supplied
        fig = plt.figure()
    fig.add_subplot(subPlotNr)
    cntMethod = 0

    color = ['blue', 'red', 'green']
    xp = np.linspace(fitInterval[0], fitInterval[1], 100)   
    
    for method in methodList:
        cumTime = 0
        CresFile = pathCresultFilesList[cntMethod] # + r'\PertTime_' + str(order) + fileId1 + method + fileId2
        #load the C-results:
        CresultsDict = readResultsCcode(inputFileName = CresFile, all_b = 0)
        
        Clist = []
        lengthListC = []
    
        #why not: for f in CresultsDict.keys():
        #L = CresultsDict[f]["str length"]??    

        for f in CresultsDict.keys():
        #            print f
        #            print CresultsDict[f].keys()
            L = CresultsDict[f]["str length"]
            try:
                timeC = float(CresultsDict[f][timeType])
                lengthListC.append(int(L))
                Clist.append(timeC)
                cumTime += timeC
            except KeyError:
                print "This file: %s was not present in C-results for method: %s" % (f, method)
        #make the plot
        plt.plot(lengthListC, Clist, '.', color = color[cntMethod], label = method, alpha = 0.75)
        #2nd order polynomial fit
        polyfitFitOrder = np.polyfit(np.array(lengthListC), Clist, deg = fitOrder, cov = False)
        print "polyfitFitOrder", polyfitFitOrder
        pFit = np.poly1d(polyfitFitOrder)
        plt.plot(xp, pFit(xp), '-', label = 'polyn. order = ' + str(fitOrder), color = color[cntMethod], alpha = 0.75)
        
        print "Total %s for method %s was: %f" % (timeType, method, cumTime) 
        cntMethod +=1

    
    # the plot
    plt.xlabel('length (nr of residues)', fontsize = 'small')
    plt.ylabel('time (s)', fontsize = 'small')
    plt.legend(loc = "upper left", fontsize = 'small')
    plt.title(title, fontsize = 'medium')

    return fig
    
    
###############################################################################
### For comparing output from Windows and Unix versions of the code
###############################################################################

'''
Last run: 30th of Oct 2017.

import gi_Anomalies as git

import gitP

#root = r'C:\Users\Christian\Bioinformatics\papers\geometric_anomalies_in_folds\c_code\results_C_5th\double_precision'
root = r'C:\Users\Christian\Bioinformatics\papers\geometric_anomalies_in_folds\c_code\test_v2\double_precision'


#read in results and compare:
order = 3
fileWin = r'\Ivalues_order_' + str(order) + '_minmax_computeGI_top100.txt'
win = git.readResultsCcode(inputFileName = root + fileWin, stringPattern = '([\S]+)[\\\]([\S]+)', pert_b = 1)
fileUnix = r'\Ivalues_order_' + str(order) + '_minmax_computeGI_top100_unix.txt'
stringPattern = '([\S]+)/([\S]+)'
print stringPattern
unix = git.readResultsCcode(inputFileName = root + fileUnix, stringPattern = stringPattern, pert_b = 1)

gitP.compareCresultsFinal(win,unix)

#Result: no diff's whatsoever.

#Check of search results:
#Restricted search
pokeLength = 10
fileWin = r'\ClosedLoopChars_minmax_computeGI_top100_loops30_pokeLength' + str(pokeLength) + '.txt'
win = git.readSearchResultsCcode(inputFileName = root + fileWin, stringPattern = '([\S]+)[\\\]([\S]+)')
fileUnix = r'\ClosedLoopChars_minmax_computeGI_top100_loops30_pokeLength' + str(pokeLength) + '_unix.txt'
stringPattern = '([\S]+)/([\S]+)'
print stringPattern
unix = git.readSearchResultsCcode(inputFileName = root + fileUnix, stringPattern = stringPattern)

gitP.compareCresultsFinal(win,unix)

#Unrestricted search
subChainLength = 15
fileWin = r'\SubChainPairChars_minmax_computeGI_top100_subChainLength' + str(subChainLength) + '.txt'
win = git.readSearchResultsCcode(inputFileName = root + fileWin, stringPattern = '([\S]+)[\\\]([\S]+)')
fileUnix = r'\SubChainPairChars_minmax_computeGI_top100_subChainLength' + str(subChainLength) + '_unix.txt'
stringPattern = '([\S]+)/([\S]+)'
print stringPattern
unix = git.readSearchResultsCcode(inputFileName = root + fileUnix, stringPattern = stringPattern)

gitP.compareCresultsFinal(win,unix)

#Result: no diff's whatsoever.
'''